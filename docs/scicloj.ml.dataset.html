<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>scicloj.ml.dataset documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scicloj</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ml</span></div></div></li><li class="depth-3 branch"><a href="scicloj.ml.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch current"><a href="scicloj.ml.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-3 branch"><a href="scicloj.ml.dvc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dvc</span></div></a></li><li class="depth-3 branch"><a href="scicloj.ml.metamorph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metamorph</span></div></a></li><li class="depth-3"><a href="scicloj.ml.try.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>try</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="scicloj.ml.dataset.html#var--.3Earray"><div class="inner"><span>-&gt;array</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-column"><div class="inner"><span>add-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-columns"><div class="inner"><span>add-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-or-replace-column"><div class="inner"><span>add-or-replace-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-or-replace-columns"><div class="inner"><span>add-or-replace-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-aggregate"><div class="inner"><span>aggregate</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-aggregate-columns"><div class="inner"><span>aggregate-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-anti-join"><div class="inner"><span>anti-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-array-column-.3Ecolumns"><div class="inner"><span>array-column-&gt;columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-as-regular-dataset"><div class="inner"><span>as-regular-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-asof-join"><div class="inner"><span>asof-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-bind"><div class="inner"><span>bind</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-boolean"><div class="inner"><span>boolean</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-by-rank"><div class="inner"><span>by-rank</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-categorical"><div class="inner"><span>categorical</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-categorical-.3Enumber"><div class="inner"><span>categorical-&gt;number</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-categorical-.3Eone-hot"><div class="inner"><span>categorical-&gt;one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-clone"><div class="inner"><span>clone</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column"><div class="inner"><span>column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-count"><div class="inner"><span>column-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-filter"><div class="inner"><span>column-filter</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-names"><div class="inner"><span>column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-values-.3Ecategorical"><div class="inner"><span>column-values-&gt;categorical</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-columns"><div class="inner"><span>columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-columns-.3Earray-column"><div class="inner"><span>columns-&gt;array-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-complete"><div class="inner"><span>complete</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-concat"><div class="inner"><span>concat</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-concat-copying"><div class="inner"><span>concat-copying</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-convert-types"><div class="inner"><span>convert-types</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-create-categorical-map"><div class="inner"><span>create-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-cross-join"><div class="inner"><span>cross-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-crosstab"><div class="inner"><span>crosstab</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset"><div class="inner"><span>dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Ecategorical-maps"><div class="inner"><span>dataset-&gt;categorical-maps</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Ecategorical-xforms"><div class="inner"><span>dataset-&gt;categorical-xforms</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Eone-hot-maps"><div class="inner"><span>dataset-&gt;one-hot-maps</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Estr"><div class="inner"><span>dataset-&gt;str</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-name"><div class="inner"><span>dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset.3F"><div class="inner"><span>dataset?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-datetime"><div class="inner"><span>datetime</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop"><div class="inner"><span>drop</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop-columns"><div class="inner"><span>drop-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop-missing"><div class="inner"><span>drop-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop-rows"><div class="inner"><span>drop-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-empty-ds.3F"><div class="inner"><span>empty-ds?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-expand"><div class="inner"><span>expand</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-feature"><div class="inner"><span>feature</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-feature-ecount"><div class="inner"><span>feature-ecount</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fill-range-replace"><div class="inner"><span>fill-range-replace</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-first"><div class="inner"><span>first</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fit-categorical-map"><div class="inner"><span>fit-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fit-one-hot"><div class="inner"><span>fit-one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fold-by"><div class="inner"><span>fold-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-full-join"><div class="inner"><span>full-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-get-entry"><div class="inner"><span>get-entry</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-grouped.3F"><div class="inner"><span>grouped?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-groups-.3Emap"><div class="inner"><span>groups-&gt;map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-groups-.3Eseq"><div class="inner"><span>groups-&gt;seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-has-column.3F"><div class="inner"><span>has-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-head"><div class="inner"><span>head</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-column.3F"><div class="inner"><span>inference-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-column-names"><div class="inner"><span>inference-target-column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-ds"><div class="inner"><span>inference-target-ds</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-label-inverse-map"><div class="inner"><span>inference-target-label-inverse-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-label-map"><div class="inner"><span>inference-target-label-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-info"><div class="inner"><span>info</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inner-join"><div class="inner"><span>inner-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-intersect"><div class="inner"><span>intersect</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-invert-categorical-map"><div class="inner"><span>invert-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-invert-one-hot-map"><div class="inner"><span>invert-one-hot-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-join-columns"><div class="inner"><span>join-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-k-fold-datasets"><div class="inner"><span>k-fold-datasets</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-labels"><div class="inner"><span>labels</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-last"><div class="inner"><span>last</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-left-join"><div class="inner"><span>left-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-map-columns"><div class="inner"><span>map-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-map-rows"><div class="inner"><span>map-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-mark-as-group"><div class="inner"><span>mark-as-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-metadata-filter"><div class="inner"><span>metadata-filter</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-missing"><div class="inner"><span>missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-model-type"><div class="inner"><span>model-type</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-no-missing"><div class="inner"><span>no-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-num-inference-classes"><div class="inner"><span>num-inference-classes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-numeric"><div class="inner"><span>numeric</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-of-datatype"><div class="inner"><span>of-datatype</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-order-by"><div class="inner"><span>order-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-pivot-.3Elonger"><div class="inner"><span>pivot-&gt;longer</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-pivot-.3Ewider"><div class="inner"><span>pivot-&gt;wider</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-prediction"><div class="inner"><span>prediction</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-print-dataset"><div class="inner"><span>print-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-probability-distribution"><div class="inner"><span>probability-distribution</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-probability-distributions-.3Elabel-column"><div class="inner"><span>probability-distributions-&gt;label-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-process-group-data"><div class="inner"><span>process-group-data</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-rand-nth"><div class="inner"><span>rand-nth</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-random"><div class="inner"><span>random</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-read-nippy"><div class="inner"><span>read-nippy</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-rename-columns"><div class="inner"><span>rename-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-reorder-columns"><div class="inner"><span>reorder-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-replace-missing"><div class="inner"><span>replace-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-reverse-map-categorical-xforms"><div class="inner"><span>reverse-map-categorical-xforms</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-right-join"><div class="inner"><span>right-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-row-count"><div class="inner"><span>row-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-rows"><div class="inner"><span>rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select-columns"><div class="inner"><span>select-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select-missing"><div class="inner"><span>select-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select-rows"><div class="inner"><span>select-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-semi-join"><div class="inner"><span>semi-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-separate-column"><div class="inner"><span>separate-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-set-dataset-name"><div class="inner"><span>set-dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-set-inference-target"><div class="inner"><span>set-inference-target</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-shape"><div class="inner"><span>shape</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-shuffle"><div class="inner"><span>shuffle</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-split"><div class="inner"><span>split</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-split-.3Eseq"><div class="inner"><span>split-&gt;seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-string"><div class="inner"><span>string</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-tail"><div class="inner"><span>tail</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-target"><div class="inner"><span>target</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-train-test-split"><div class="inner"><span>train-test-split</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-transform-categorical-map"><div class="inner"><span>transform-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-transform-one-hot"><div class="inner"><span>transform-one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-ungroup"><div class="inner"><span>ungroup</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-unique-by"><div class="inner"><span>unique-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-unmark-group"><div class="inner"><span>unmark-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-unroll"><div class="inner"><span>unroll</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-update-columns"><div class="inner"><span>update-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-write.21"><div class="inner"><span>write!</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-write-csv.21"><div class="inner"><span>write-csv!</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-write-nippy.21"><div class="inner"><span>write-nippy!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">scicloj.ml.dataset</h1><div class="doc"><div class="markdown"><p>This namespace contains functions which operate on a dataset and mostly return a dataset.</p>
<p>The namespaces scicloj.ml.metamorph and scicloj.ml.dataset contain functions with the same name. But they operate on either a context map (ns metamorph) or on a dataset (ns dataset)</p>
<p>The functions in tis namespace are re-exported from:</p>
<ul>
  <li>tabecloth.api - docs at <a href="https://scicloj.github.io/tablecloth/">https://scicloj.github.io/tablecloth/</a></li>
  <li>tech.v3.dataset.modelling</li>
  <li>tech.v3.dataset.column-filters</li>
</ul></div></div><div class="public anchor" id="var--.3Earray"><h3>-&gt;array</h3><div class="usage"><code>(-&gt;array ds colname)</code><code>(-&gt;array ds colname datatype)</code></div><div class="doc"><div class="markdown"><p>Convert numerical column(s) to java array</p></div></div></div><div class="public anchor" id="var-add-column"><h3>add-column</h3><div class="usage"><code>(add-column ds column-name column)</code><code>(add-column ds column-name column size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or update (modify) column under <code>column-name</code>.</p>
<p><code>column</code> can be sequence of values or generator function (which gets <code>ds</code> as input).</p>
<ul>
  <li><code>ds</code> - a dataset</li>
  <li><code>column-name</code> - if it’s existing column name, column will be replaced</li>
  <li><code>column</code> - can be column (from other dataset), sequence, single value or function (taking a dataset). Too big columns are always trimmed. Too small are cycled or extended with missing values (according to <code>size-strategy</code> argument)</li>
  <li><code>size-strategy</code> (optional) - when new column is shorter than dataset row count, following strategies are applied:</li>
  <li><code>:cycle</code> - repeat data</li>
  <li><code>:na</code> - append missing values</li>
  <li><code>:strict</code> - (default) throws an exception when sizes mismatch</li>
</ul></div></div></div><div class="public anchor" id="var-add-columns"><h3>add-columns</h3><div class="usage"><code>(add-columns ds columns-map)</code><code>(add-columns ds columns-map size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or updade (modify) columns defined in <code>columns-map</code> (mapping: name -&gt; column) </p></div></div></div><div class="public anchor" id="var-add-or-replace-column"><h3>add-or-replace-column</h3><div class="usage"><code>(add-or-replace-column ds column-name column)</code><code>(add-or-replace-column ds column-name column size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-or-replace-columns"><h3>add-or-replace-columns</h3><div class="usage"><code>(add-or-replace-columns ds columns-map)</code><code>(add-or-replace-columns ds columns-map size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-aggregate"><h3>aggregate</h3><div class="usage"><code>(aggregate ds aggregator)</code><code>(aggregate ds aggregator options)</code></div><div class="doc"><div class="markdown"><p>Aggregate dataset by providing:</p>
<ul>
  <li>aggregation function</li>
  <li>map with column names and functions</li>
  <li>sequence of aggregation functions</li>
</ul>
<p>Aggregation functions can return: - single value - seq of values - map of values with column names</p></div></div></div><div class="public anchor" id="var-aggregate-columns"><h3>aggregate-columns</h3><div class="usage"><code>(aggregate-columns ds columns-aggregators)</code><code>(aggregate-columns ds columns-selector column-aggregators)</code><code>(aggregate-columns ds columns-selector column-aggregators options)</code></div><div class="doc"><div class="markdown"><p>Aggregates each column separately</p></div></div></div><div class="public anchor" id="var-anti-join"><h3>anti-join</h3><div class="usage"><code>(anti-join ds-left ds-right columns-selector)</code><code>(anti-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append ds &amp; args)</code></div><div class="doc"><div class="markdown"><p>Concats columns of several datasets</p></div></div></div><div class="public anchor" id="var-array-column-.3Ecolumns"><h3>array-column-&gt;columns</h3><div class="usage"><code>(array-column-&gt;columns ds src-column opts)</code><code>(array-column-&gt;columns ds src-column)</code></div><div class="doc"><div class="markdown"><p>Converts a column of type java array into several columns, one for each element of the array of all rows. The source column is dropped afterwards. The function assumes that arrays in all rows have same type and length and are numeric.</p>
<p><code>ds</code> Datset to operate on. <code>src-column</code> The (array) column to convert <code>opts</code> can contain:  <code>prefix</code> newly created column will get prefix before column number</p></div></div></div><div class="public anchor" id="var-as-regular-dataset"><h3>as-regular-dataset</h3><div class="usage"><code>(as-regular-dataset ds)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-asof-join"><h3>asof-join</h3><div class="usage"><code>(asof-join ds-left ds-right columns-selector)</code><code>(asof-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind ds &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-boolean"><h3>boolean</h3><div class="usage"><code>(boolean dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the boolean columns.</p></div></div></div><div class="public anchor" id="var-by-rank"><h3>by-rank</h3><div class="usage"><code>(by-rank ds columns-selector rank-predicate)</code><code>(by-rank ds columns-selector rank-predicate options)</code></div><div class="doc"><div class="markdown"><p>Select rows using <code>rank</code> on a column, ties are resolved using <code>:dense</code> method.</p>
<p>See <a href="https://www.rdocumentation.org/packages/base/versions/3.6.1/topics/rank">R docs</a>. Rank uses 0 based indexing.</p>
<p>Possible <code>:ties</code> strategies: <code>:average</code>, <code>:first</code>, <code>:last</code>, <code>:random</code>, <code>:min</code>, <code>:max</code>, <code>:dense</code>. <code>:dense</code> is the same as in <code>data.table::frank</code> from R</p>
<p><code>:desc?</code> set to true (default) order descending before calculating rank</p></div></div></div><div class="public anchor" id="var-categorical"><h3>categorical</h3><div class="usage"><code>(categorical dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the categorical columns.</p></div></div></div><div class="public anchor" id="var-categorical-.3Enumber"><h3>categorical-&gt;number</h3><div class="usage"><code>(categorical-&gt;number dataset filter-fn-or-ds)</code><code>(categorical-&gt;number dataset filter-fn-or-ds table-args)</code><code>(categorical-&gt;number dataset filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert columns into a discrete , numeric representation See tech.v3.dataset.categorical/fit-categorical-map.</p></div></div></div><div class="public anchor" id="var-categorical-.3Eone-hot"><h3>categorical-&gt;one-hot</h3><div class="usage"><code>(categorical-&gt;one-hot dataset filter-fn-or-ds)</code><code>(categorical-&gt;one-hot dataset filter-fn-or-ds table-args)</code><code>(categorical-&gt;one-hot dataset filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert string columns to numeric columns. See tech.v3.dataset.categorical/fit-one-hot</p></div></div></div><div class="public anchor" id="var-clone"><h3>clone</h3><div class="usage"><code>(clone item)</code></div><div class="doc"><div class="markdown"><p>Clone an object. Can clone anything convertible to a reader.</p></div></div></div><div class="public anchor" id="var-column"><h3>column</h3><div class="usage"><code>(column dataset colname)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-count"><h3>column-count</h3><div class="usage"><code>(column-count dataset)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-filter"><h3>column-filter</h3><div class="usage"><code>(column-filter dataset filter-fn)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only the columns for which the filter function returns a truthy value.</p></div></div></div><div class="public anchor" id="var-column-names"><h3>column-names</h3><div class="usage"><code>(column-names ds)</code><code>(column-names ds columns-selector)</code><code>(column-names ds columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Returns column names, given a selector.  Columns-selector can be one of the following:</p>
<ul>
  <li>:all keyword - selects all columns</li>
  <li>column name - for single column</li>
  <li>sequence of column names - for collection of columns</li>
  <li>regex - to apply pattern on column names or datatype</li>
  <li>filter predicate - to filter column names or datatype</li>
  <li>type namespaced keyword for specific datatype or group of datatypes</li>
</ul>
<p>Column name can be anything.</p>
<p>column-names function returns names according to columns-selector  and optional meta-field. meta-field is one of the following:</p>
<ul>
  <li><code>:name</code> (default) - to operate on column names</li>
  <li><code>:datatype</code> - to operated on column types</li>
  <li><code>:all</code> - if you want to process all metadata</li>
</ul>
<p>Datatype groups are:</p>
<ul>
  <li><code>:type/numerical</code> - any numerical type</li>
  <li><code>:type/float</code> - floating point number (:float32 and :float64)</li>
  <li><code>:type/integer</code> - any integer</li>
  <li><code>:type/datetime</code> - any datetime type</li>
</ul>
<p>If qualified keyword starts with :!type, complement set is used.</p></div></div></div><div class="public anchor" id="var-column-values-.3Ecategorical"><h3>column-values-&gt;categorical</h3><div class="usage"><code>(column-values-&gt;categorical dataset src-column)</code></div><div class="doc"><div class="markdown"><p>Given a column encoded via either string-&gt;number or one-hot, reverse map to the a sequence of the original string column values. In the case of one-hot mappings, src-column must be the original column name before the one-hot map</p></div></div></div><div class="public anchor" id="var-columns"><h3>columns</h3><div class="usage"><code>(columns ds)</code><code>(columns ds result-type)</code></div><div class="doc"><div class="markdown"><p>Returns columns of dataset. Result type can be any of: * <code>:as-map</code> * <code>:as-double-arrays</code> * <code>:as-seqs</code></p></div></div></div><div class="public anchor" id="var-columns-.3Earray-column"><h3>columns-&gt;array-column</h3><div class="usage"><code>(columns-&gt;array-column ds column-selector new-column)</code></div><div class="doc"><div class="markdown"><p>Converts several columns to a single column of type array.  The src columns are dropped afterwards.</p>
<p><code>ds</code> Dataset to operate on. <code>column-selector</code> anything supported by <a href="scicloj.ml.dataset.html#var-select-columns">select-columns</a> <code>new-column</code> new column to create</p></div></div></div><div class="public anchor" id="var-complete"><h3>complete</h3><div class="usage"><code>(complete ds columns-selector &amp; args)</code></div><div class="doc"><div class="markdown"><p>TidyR complete.</p>
<p>Fills a dataset with all possible combinations of selected columns. When a given combination doesn’t exist, missing values are created.</p></div></div></div><div class="public anchor" id="var-concat"><h3>concat</h3><div class="usage"><code>(concat dataset &amp; args)</code></div><div class="doc"><div class="markdown"><p>Joins rows from other datasets</p></div></div></div><div class="public anchor" id="var-concat-copying"><h3>concat-copying</h3><div class="usage"><code>(concat-copying dataset &amp; args)</code></div><div class="doc"><div class="markdown"><p>Joins rows from other datasets via a copy of data</p></div></div></div><div class="public anchor" id="var-convert-types"><h3>convert-types</h3><div class="usage"><code>(convert-types ds coltype-map-or-columns-selector)</code><code>(convert-types ds columns-selector new-types)</code></div><div class="doc"><div class="markdown"><p>Convert type of the column to the other type.</p></div></div></div><div class="public anchor" id="var-create-categorical-map"><h3>create-categorical-map</h3><div class="usage"><code>(create-categorical-map lookup-table src-colname result-datatype)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-cross-join"><h3>cross-join</h3><div class="usage"><code>(cross-join ds-left ds-right)</code><code>(cross-join ds-left ds-right columns-selector)</code><code>(cross-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Cross product from selected columns</p></div></div></div><div class="public anchor" id="var-crosstab"><h3>crosstab</h3><div class="usage"><code>(crosstab ds row-selector col-selector)</code><code>(crosstab ds row-selector col-selector options)</code></div><div class="doc"><div class="markdown"><p>Cross tabulation of two sets of columns.</p>
<p>Creates grouped dataset by [row-selector, col-selector] pairs and calls aggregation on each group.</p>
<p>Options:</p>
<ul>
  <li>pivot? - create pivot table or just flat structure (default: true)</li>
  <li>replace-missing? - replace missing values? (default: true)</li>
  <li>missing-value - a missing value (default: 0)</li>
  <li>aggregator - aggregating function (default: row-count)</li>
  <li>marginal-rows, marginal-cols - adds row and/or cols, it’s a sum if true. Can be a custom fn.</li>
</ul></div></div></div><div class="public anchor" id="var-dataset"><h3>dataset</h3><div class="usage"><code>(dataset)</code><code>(dataset data)</code><code>(dataset data options)</code></div><div class="doc"><div class="markdown"><p>Create a <code>dataset</code>.</p>
<p>Dataset can be created from:</p>
<ul>
  <li>map of values and/or sequences</li>
  <li>sequence of maps</li>
  <li>sequence of columns</li>
  <li>file or url</li>
  <li>array of arrays</li>
  <li>single value</li>
</ul>
<p>Single value is set only when it’s not possible to find a path for given data. If tech.ml.dataset throws an exception, it’s won;t be printed. To print a stack trace, set <code>stack-trace?</code> option to <code>true</code>.</p>
<p>ds/-&gt;dataset documentation:</p>
<p>Create a dataset from either csv/tsv or a sequence of maps.</p>
<ul>
  <li>
  <p>A <code>String</code> be interpreted as a file (or gzipped file if it  ends with .gz) of tsv or csv data. The system will attempt to autodetect if this  is csv or tsv and then engineering around detecting datatypes all of which can  be overridden.</p></li>
  <li>
  <p>InputStreams have no file type and thus a <code>file-type</code> must be provided in the  options.</p></li>
  <li>
  <p>A sequence of maps may be passed in in which case the first N maps are scanned in  order to derive the column datatypes before the actual columns are created.</p></li>
</ul>
<p>Parquet, xlsx, and xls formats require that you require the appropriate libraries which are <code>tech.v3.libs.parquet</code> for parquet, <code>tech.v3.libs.fastexcel</code> for xlsx, and <code>tech.v3.libs.poi</code> for xls.</p>
<p>Arrow support is provided via the tech.v3.libs.Arrow namespace not via a file-type overload as the Arrow project current has 3 different file types and it is not clear what their final suffix will be or which of the three file types it will indicate. Please see documentation in the <code>tech.v3.libs.arrow</code> namespace for further information on Arrow file types.</p>
<p>Options:</p>
<ul>
  <li><code>:dataset-name</code> - set the name of the dataset.</li>
  <li>
  <p><code>:file-type</code> - Override filetype discovery mechanism for strings or force a particular parser for an input stream. Note that parquet must have paths on disk and cannot currently load from input stream. Acceptible file types are:</p>#{:csv :tsv :xlsx :xls :parquet}.</li>
  <li><code>:gzipped?</code> - for file formats that support it, override autodetection and force  creation of a gzipped input stream as opposed to a normal input stream.</li>
  <li><code>:column-whitelist</code> - either sequence of string column names or sequence of column  indices of columns to whitelist.</li>
  <li><code>:column-blacklist</code> - either sequence of string column names or sequence of column  indices of columns to blacklist.</li>
  <li><code>:num-rows</code> - Number of rows to read</li>
  <li><code>:header-row?</code> - Defaults to true, indicates the first row is a header.</li>
  <li><code>:key-fn</code> - function to be applied to column names. Typical use is:  <code>:key-fn keyword</code>.</li>
  <li><code>:separator</code> - Add a character separator to the list of separators to auto-detect.</li>
  <li><code>:csv-parser</code> - Implementation of univocity’s AbstractParser to use. If not  provided a default permissive parser is used. This way you parse anything that  univocity supports (so flat files and such).</li>
  <li><code>:bad-row-policy</code> - One of three options: :skip, :error, :carry-on. Defaults to  :carry-on. Some csv data has ragged rows and in this case we have several  options. If the option is :carry-on then we either create a new column or add  missing values for columns that had no data for that row.</li>
  <li><code>:skip-bad-rows?</code> - Legacy option. Use :bad-row-policy.</li>
  <li><code>:disable-comment-skipping?</code> - As default, the <code>#</code> character is recognised as a  line comment when found in the beginning of a line of text in a CSV file,  and the row will be ignored. Set <code>true</code> to disable this behavior.</li>
  <li><code>:max-chars-per-column</code> - Defaults to 4096. Columns with more characters that this  will result in an exception.</li>
  <li><code>:max-num-columns</code> - Defaults to 8192. CSV,TSV files with more columns than this  will fail to parse. For more information on this option, please visit:  <a href="https://github.com/uniVocity/univocity-parsers/issues/301">https://github.com/uniVocity/univocity-parsers/issues/301</a></li>
  <li><code>:text-temp-dir</code> - The temporary directory to use for file-backed text. Setting  this value to boolean ‘false’ turns off file backed text which is the default. If a  tech.v3.resource stack context is opened the file will be deleted when the context  closes else it will be deleted when the gc cleans up the dataset. A shutdown hook is  added as a last resort to ensure the file is cleaned up.</li>
  <li><code>:n-initial-skip-rows</code> - Skip N rows initially. This currently may include the  header row. Works across both csv and spreadsheet datasets.</li>
  <li><code>:parser-type</code> - Default parser to use if no parser-fn is specified for that column.  For csv files, the default parser type is <code>:string</code> which indicates a promotional  string parser. For sequences of maps, the default parser type is :object. It can  be useful in some contexts to use the <code>:string</code> parser with sequences of maps or  maps of columns.</li>
  <li><code>:parser-fn</code> -
    <ul>
      <li><code>keyword?</code> - all columns parsed to this datatype. For example:  <code>{:parser-fn :string}</code></li>
      <li><code>map?</code> - <code>{column-name parse-method}</code> parse each column with specified  <code>parse-method</code>.  The <code>parse-method</code> can be:
        <ul>
          <li><code>keyword?</code> - parse the specified column to this datatype. For example:  <code>{:parser-fn {:answer :boolean :id :int32}}</code></li>
          <li>tuple - pair of <code>[datatype parse-data]</code> in which case container of type  <code>[datatype]</code> will be created. <code>parse-data</code> can be one of:
            <ul>
              <li><code>:relaxed?</code> - data will be parsed such that parse failures of the standard  parse functions do not stop the parsing process. :unparsed-values and  :unparsed-indexes are available in the metadata of the column that tell  you the values that failed to parse and their respective indexes.</li>
              <li><code>fn?</code> - function from str-&gt; one of <code>:tech.v3.dataset/missing</code>,  <code>:tech.v3.dataset/parse-failure</code>, or the parsed value.  Exceptions here always kill the parse process. :missing will get marked  in the missing indexes, and :parse-failure will result in the index being  added to missing, the unparsed the column’s :unparsed-values and  :unparsed-indexes will be updated.</li>
              <li><code>string?</code> - for datetime types, this will turned into a DateTimeFormatter via  DateTimeFormatter/ofPattern. For <code>:text</code> you can specify the backing file  to use.</li>
              <li><code>DateTimeFormatter</code> - use with the appropriate temporal parse static function  to parse the value.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
  <p><code>map?</code> - the header-name-or-idx is used to lookup value. If not nil, then  value can be any of the above options. Else the default column parser  is used.</p></li>
</ul>
<p>Returns a new dataset</p></div></div></div><div class="public anchor" id="var-dataset-.3Ecategorical-maps"><h3>dataset-&gt;categorical-maps</h3><div class="usage"><code>(dataset-&gt;categorical-maps dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a map of column names to categorical label maps. This aids in inverting all of the label maps in a dataset. The source column name is src-column.</p></div></div></div><div class="public anchor" id="var-dataset-.3Ecategorical-xforms"><h3>dataset-&gt;categorical-xforms</h3><div class="usage"><code>(dataset-&gt;categorical-xforms ds)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a map of column-name-&gt;xform information.</p></div></div></div><div class="public anchor" id="var-dataset-.3Eone-hot-maps"><h3>dataset-&gt;one-hot-maps</h3><div class="usage"><code>(dataset-&gt;one-hot-maps dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a sequence of applied on-hot transformations.</p></div></div></div><div class="public anchor" id="var-dataset-.3Estr"><h3>dataset-&gt;str</h3><div class="usage"><code>(dataset-&gt;str ds options)</code><code>(dataset-&gt;str ds)</code></div><div class="doc"><div class="markdown"><p>Convert a dataset to a string. Prints a single line header and then calls dataset-data-&gt;str.</p>
<p>For options documentation see dataset-data-&gt;str.</p></div></div></div><div class="public anchor" id="var-dataset-name"><h3>dataset-name</h3><div class="usage"><code>(dataset-name dataset)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-dataset.3F"><h3>dataset?</h3><div class="usage"><code>(dataset? ds)</code></div><div class="doc"><div class="markdown"><p>Is <code>ds</code> a <code>dataset</code> type?</p></div></div></div><div class="public anchor" id="var-datetime"><h3>datetime</h3><div class="usage"><code>(datetime dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the datetime columns.</p></div></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference ds-left ds-right)</code><code>(difference ds-left ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-drop"><h3>drop</h3><div class="usage"><code>(drop ds columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Drop columns and rows.</p></div></div></div><div class="public anchor" id="var-drop-columns"><h3>drop-columns</h3><div class="usage"><code>(drop-columns ds)</code><code>(drop-columns ds columns-selector)</code><code>(drop-columns ds columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Drop columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-drop-missing"><h3>drop-missing</h3><div class="usage"><code>(drop-missing ds)</code><code>(drop-missing ds columns-selector)</code></div><div class="doc"><div class="markdown"><p>Drop rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-drop-rows"><h3>drop-rows</h3><div class="usage"><code>(drop-rows ds)</code><code>(drop-rows ds rows-selector)</code><code>(drop-rows ds rows-selector options)</code></div><div class="doc"><div class="markdown"><p>Drop rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-empty-ds.3F"><h3>empty-ds?</h3><div class="usage"><code>(empty-ds? ds)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-expand"><h3>expand</h3><div class="usage"><code>(expand ds columns-selector &amp; args)</code></div><div class="doc"><div class="markdown"><p>TidyR expand.</p>
<p>Creates all possible combinations of selected columns.</p></div></div></div><div class="public anchor" id="var-feature"><h3>feature</h3><div class="usage"><code>(feature dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset container only the columns which have not been marked as inference columns.</p></div></div></div><div class="public anchor" id="var-feature-ecount"><h3>feature-ecount</h3><div class="usage"><code>(feature-ecount dataset)</code></div><div class="doc"><div class="markdown"><p>Number of feature columns. Feature columns are columns that are not inference targets.</p></div></div></div><div class="public anchor" id="var-fill-range-replace"><h3>fill-range-replace</h3><div class="usage"><code>(fill-range-replace ds colname max-span)</code><code>(fill-range-replace ds colname max-span missing-strategy)</code><code>(fill-range-replace ds colname max-span missing-strategy missing-value)</code></div><div class="doc"><div class="markdown"><p>Fill missing up with lacking values. Accepts * dataset * column name * expected step (max-span, milliseconds in case of datetime column) * (optional) missing-strategy - how to replace missing, default :down (set to nil if none) * (optional) missing-value - optional value for replace missing</p></div></div></div><div class="public anchor" id="var-first"><h3>first</h3><div class="usage"><code>(first ds)</code></div><div class="doc"><div class="markdown"><p>First row</p></div></div></div><div class="public anchor" id="var-fit-categorical-map"><h3>fit-categorical-map</h3><div class="usage"><code>(fit-categorical-map dataset colname &amp; args)</code></div><div class="doc"><div class="markdown"><p>Given a column, map it into an numeric space via a discrete map of values to integers. This fits the categorical transformation onto the column and returns the transformation.</p>
<p>If <code>table-args</code> is not given, the distinct column values will be mapped into 0..x without any specific order.</p>
<p>’table-args` allows to specify the precise mapping as a sequence of pairs of [val idx] or as a sorted seq of values.</p></div></div></div><div class="public anchor" id="var-fit-one-hot"><h3>fit-one-hot</h3><div class="usage"><code>(fit-one-hot dataset colname &amp; args)</code></div><div class="doc"><div class="markdown"><p>Fit a one hot transformation to a column. Returns a reusable transformation. Maps each unique value to a column with 1 every time the value appears in the original column and 0 otherwise.</p></div></div></div><div class="public anchor" id="var-fold-by"><h3>fold-by</h3><div class="usage"><code>(fold-by ds columns-selector)</code><code>(fold-by ds columns-selector folding-function)</code></div><div class="doc"><div class="markdown"><p>Group-by and pack columns into vector - the output data set has a row for each unique combination of the provided columns while each remaining column has its valu(es) collected into a vector, similar to how clojure.core/group-by works. See <a href="https://scicloj.github.io/tablecloth/index.html#Fold-by">https://scicloj.github.io/tablecloth/index.html#Fold-by</a></p></div></div></div><div class="public anchor" id="var-full-join"><h3>full-join</h3><div class="usage"><code>(full-join ds-left ds-right columns-selector)</code><code>(full-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Join keeping all rows</p></div></div></div><div class="public anchor" id="var-get-entry"><h3>get-entry</h3><div class="usage"><code>(get-entry ds column row)</code></div><div class="doc"><div class="markdown"><p>Returns a single value from given column and row</p></div></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><div class="usage"><code>(group-by ds grouping-selector)</code><code>(group-by ds grouping-selector options)</code></div><div class="doc"><div class="markdown"><p>Group dataset by:</p>
<ul>
  <li>column name</li>
  <li>list of columns</li>
  <li>map of keys and row indexes</li>
  <li>function getting map of values</li>
</ul>
<p>Options are:</p>
<ul>
  <li>select-keys - when grouping is done by function, you can limit fields to a <code>select-keys</code> seq.</li>
  <li>result-type - return results as dataset (<code>:as-dataset</code>, default) or as map of datasets (<code>:as-map</code>) or as map of row indexes (<code>:as-indexes</code>) or as sequence of (sub)datasets</li>
  <li>other parameters which are passed to <code>dataset</code> fn</li>
</ul>
<p>When dataset is returned, meta contains <code>:grouped?</code> set to true. Columns in dataset:</p>
<ul>
  <li>name - group name</li>
  <li>group-id - id of the group (int)</li>
  <li>data - group as dataset</li>
</ul></div></div></div><div class="public anchor" id="var-grouped.3F"><h3>grouped?</h3><div class="usage"><code>(grouped? ds)</code></div><div class="doc"><div class="markdown"><p>Is <code>dataset</code> represents grouped dataset (result of <code>group-by</code>)?</p></div></div></div><div class="public anchor" id="var-groups-.3Emap"><h3>groups-&gt;map</h3><div class="usage"><code>(groups-&gt;map ds)</code></div><div class="doc"><div class="markdown"><p>Convert grouped dataset to the map of groups</p></div></div></div><div class="public anchor" id="var-groups-.3Eseq"><h3>groups-&gt;seq</h3><div class="usage"><code>(groups-&gt;seq ds)</code></div><div class="doc"><div class="markdown"><p>Convert grouped dataset to seq of the groups</p></div></div></div><div class="public anchor" id="var-has-column.3F"><h3>has-column?</h3><div class="usage"><code>(has-column? dataset column-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-head"><h3>head</h3><div class="usage"><code>(head ds)</code><code>(head ds n)</code></div><div class="doc"><div class="markdown"><p>First n rows (default 5)</p></div></div></div><div class="public anchor" id="var-inference-column.3F"><h3>inference-column?</h3><div class="usage"><code>(inference-column? col)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inference-target-column-names"><h3>inference-target-column-names</h3><div class="usage"><code>(inference-target-column-names ds)</code></div><div class="doc"><div class="markdown"><p>Return the names of the columns that are inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-ds"><h3>inference-target-ds</h3><div class="usage"><code>(inference-target-ds dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset return reverse-mapped inference target columns or nil in the case where there are no inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-label-inverse-map"><h3>inference-target-label-inverse-map</h3><div class="usage"><code>(inference-target-label-inverse-map dataset &amp; args)</code></div><div class="doc"><div class="markdown"><p>Given options generated during ETL operations and annotated with :label-columns sequence container 1 label column, generate a reverse map that maps from a dataset value back to the label that generated that value.</p></div></div></div><div class="public anchor" id="var-inference-target-label-map"><h3>inference-target-label-map</h3><div class="usage"><code>(inference-target-label-map dataset &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-info"><h3>info</h3><div class="usage"><code>(info ds)</code><code>(info ds result-type)</code></div><div class="doc"><div class="markdown"><p>Returns a statistcial information about the columns of a dataset. <code>result-type</code> can be :descriptive or :columns</p></div></div></div><div class="public anchor" id="var-inner-join"><h3>inner-join</h3><div class="usage"><code>(inner-join ds-left ds-right columns-selector)</code><code>(inner-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-intersect"><h3>intersect</h3><div class="usage"><code>(intersect ds-left ds-right)</code><code>(intersect ds-left ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><div class="usage"><code>(intersection lhs-ds rhs-ds)</code></div><div class="doc"><div class="markdown"><p>Return only columns for rhs for which an equivalently named column exists in lhs.</p></div></div></div><div class="public anchor" id="var-invert-categorical-map"><h3>invert-categorical-map</h3><div class="usage"><code>(invert-categorical-map dataset opts)</code></div><div class="doc"><div class="markdown"><p>Invert a categorical map returning the column to the original set of values.</p></div></div></div><div class="public anchor" id="var-invert-one-hot-map"><h3>invert-one-hot-map</h3><div class="usage"><code>(invert-one-hot-map dataset opts)</code></div><div class="doc"><div class="markdown"><p>Invert a one-hot transformation removing the one-hot columns and adding back the original column.</p></div></div></div><div class="public anchor" id="var-join-columns"><h3>join-columns</h3><div class="usage"><code>(join-columns ds target-column columns-selector)</code><code>(join-columns ds target-column columns-selector conf)</code></div><div class="doc"><div class="markdown"><p>Join clumns of dataset. Accepts: dataset column selector (as in select-columns) options <code>:separator</code> (default -) <code>:drop-columns?</code> - whether to drop source columns or not (default true) <code>:result-type</code>  <code>:map</code> - packs data into map  <code>:seq</code> - packs data into sequence  <code>:string</code> - join strings with separator (default)  or custom function which gets row as a vector <code>:missing-subst</code> - substitution for missing value</p></div></div></div><div class="public anchor" id="var-k-fold-datasets"><h3>k-fold-datasets</h3><div class="usage"><code>(k-fold-datasets dataset k options)</code><code>(k-fold-datasets dataset k)</code></div><div class="doc"><div class="markdown"><p>Given 1 dataset, prepary K datasets using the k-fold algorithm. Randomize dataset defaults to true which will realize the entire dataset so use with care if you have large datasets.</p>
<p>Returns a sequence of {:test-ds :train-ds}</p>
<p>Options:</p>
<ul>
  <li><code>:randomize-dataset?</code> - When true, shuffle the dataset. In that case ‘seed’ may be  provided. Defaults to true.</li>
  <li><code>:seed</code> - when <code>:randomize-dataset?</code> is true then this can either be an  implementation of java.util.Random or an integer seed which will be used to  construct java.util.Random.</li>
</ul></div></div></div><div class="public anchor" id="var-labels"><h3>labels</h3><div class="usage"><code>(labels dataset)</code></div><div class="doc"><div class="markdown"><p>Return the labels. The labels sequence is the reverse mapped inference column. This returns a single column of data or errors out.</p></div></div></div><div class="public anchor" id="var-last"><h3>last</h3><div class="usage"><code>(last ds)</code></div><div class="doc"><div class="markdown"><p>Last row</p></div></div></div><div class="public anchor" id="var-left-join"><h3>left-join</h3><div class="usage"><code>(left-join ds-left ds-right columns-selector)</code><code>(left-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-map-columns"><h3>map-columns</h3><div class="usage"><code>(map-columns ds column-name map-fn)</code><code>(map-columns ds column-name columns-selector map-fn)</code><code>(map-columns ds column-name new-type columns-selector map-fn)</code></div><div class="doc"><div class="markdown"><p>Map over rows using a map function. The arity should match the columns selected.</p></div></div></div><div class="public anchor" id="var-map-rows"><h3>map-rows</h3><div class="usage"><code>(map-rows ds map-fn)</code><code>(map-rows ds map-fn options)</code></div><div class="doc"><div class="markdown"><p>Map a function across the rows of the dataset producing a new dataset that is merged back into the original potentially replacing existing columns.</p></div></div></div><div class="public anchor" id="var-mark-as-group"><h3>mark-as-group</h3><div class="usage"><code>(mark-as-group ds)</code></div><div class="doc"><div class="markdown"><p>Add grouping tag</p></div></div></div><div class="public anchor" id="var-metadata-filter"><h3>metadata-filter</h3><div class="usage"><code>(metadata-filter dataset filter-fn)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only the columns for which, given the column metadata, the filter function returns a truthy value.</p></div></div></div><div class="public anchor" id="var-missing"><h3>missing</h3><div class="usage"><code>(missing dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only columns have have missing values</p></div></div></div><div class="public anchor" id="var-model-type"><h3>model-type</h3><div class="usage"><code>(model-type dataset &amp; args)</code></div><div class="doc"><div class="markdown"><p>Check the label column after dataset processing. Return either :regression :classification</p></div></div></div><div class="public anchor" id="var-no-missing"><h3>no-missing</h3><div class="usage"><code>(no-missing dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only columns that have no missing values.</p></div></div></div><div class="public anchor" id="var-num-inference-classes"><h3>num-inference-classes</h3><div class="usage"><code>(num-inference-classes dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset and correctly built options from pipeline operations, return the number of classes used for the label. Error if not classification dataset.</p></div></div></div><div class="public anchor" id="var-numeric"><h3>numeric</h3><div class="usage"><code>(numeric dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the numeric columns.</p></div></div></div><div class="public anchor" id="var-of-datatype"><h3>of-datatype</h3><div class="usage"><code>(of-datatype dataset datatype)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the columns of a specific datatype.</p></div></div></div><div class="public anchor" id="var-order-by"><h3>order-by</h3><div class="usage"><code>(order-by ds columns-or-fn)</code><code>(order-by ds columns-or-fn comparators)</code><code>(order-by ds columns-or-fn comparators options)</code></div><div class="doc"><div class="markdown"><p>Order dataset by: - column name - columns (as sequence of names) - key-fn - sequence of columns / key-fn Additionally you can ask the order by: - :asc - :desc - custom comparator function</p></div></div></div><div class="public anchor" id="var-pivot-.3Elonger"><h3>pivot-&gt;longer</h3><div class="usage"><code>(pivot-&gt;longer ds)</code><code>(pivot-&gt;longer ds columns-selector)</code><code>(pivot-&gt;longer ds columns-selector options)</code></div><div class="doc"><div class="markdown"><p><code>tidyr</code> pivot_longer api</p></div></div></div><div class="public anchor" id="var-pivot-.3Ewider"><h3>pivot-&gt;wider</h3><div class="usage"><code>(pivot-&gt;wider ds columns-selector value-columns)</code><code>(pivot-&gt;wider ds columns-selector value-columns options)</code></div><div class="doc"><div class="markdown"><p>Converts columns to rows. Arguments: * dataset * columns selector * options:  <code>:target-columns</code> - names of the columns created or columns pattern (see below) (default: :$column)  <code>:value-column-name</code> - name of the column for values (default: :$value)  <code>:splitter</code> - string, regular expression or function which splits source column names into data  <code>:drop-missing?</code> - remove rows with missing? (default: true)  <code>:datatypes</code> - map of target columns data types  <code>:coerce-to-number</code> - try to convert extracted values to numbers if possible (default: true)</p>
<ul>
  <li>
  <p>target-columns - can be:</p></li>
  <li>
  <p>column name - source columns names are put there as a data</p></li>
  <li>column names as seqence - source columns names after split are put separately into :target-columns as data</li>
  <li>pattern - is a sequence of names, where some of the names are nil. nil is replaced by a name taken from splitter and such column is used for values.</li>
</ul></div></div></div><div class="public anchor" id="var-prediction"><h3>prediction</h3><div class="usage"><code>(prediction dataset)</code></div><div class="doc"><div class="markdown"><p>Return the columns of the dataset marked as predictions.</p></div></div></div><div class="public anchor" id="var-print-dataset"><h3>print-dataset</h3><div class="usage"><code>(print-dataset ds)</code><code>(print-dataset ds options)</code></div><div class="doc"><div class="markdown"><p>Prints dataset into console. For options see tech.v3.dataset.print/dataset-data-&gt;str</p></div></div></div><div class="public anchor" id="var-probability-distribution"><h3>probability-distribution</h3><div class="usage"><code>(probability-distribution dataset)</code></div><div class="doc"><div class="markdown"><p>Return the columns of the dataset that comprise the probability distribution after classification.</p></div></div></div><div class="public anchor" id="var-probability-distributions-.3Elabel-column"><h3>probability-distributions-&gt;label-column</h3><div class="usage"><code>(probability-distributions-&gt;label-column prob-ds dst-colname)</code></div><div class="doc"><div class="markdown"><p>Given a dataset that has columns in which the column names describe labels and the rows describe a probability distribution, create a label column by taking the max value in each row and assign column that row value.</p></div></div></div><div class="public anchor" id="var-process-group-data"><h3>process-group-data</h3><div class="usage"><code>(process-group-data ds f)</code><code>(process-group-data ds f parallel?)</code></div><div class="doc"><div class="markdown"><p>Internal: The passed-in function is applied on all groups</p></div></div></div><div class="public anchor" id="var-rand-nth"><h3>rand-nth</h3><div class="usage"><code>(rand-nth ds)</code><code>(rand-nth ds options)</code></div><div class="doc"><div class="markdown"><p>Returns single random row</p></div></div></div><div class="public anchor" id="var-random"><h3>random</h3><div class="usage"><code>(random ds)</code><code>(random ds n)</code><code>(random ds n options)</code></div><div class="doc"><div class="markdown"><p>Returns (n) random rows with repetition</p></div></div></div><div class="public anchor" id="var-read-nippy"><h3>read-nippy</h3><div class="usage"><code>(read-nippy filename)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rename-columns"><h3>rename-columns</h3><div class="usage"><code>(rename-columns ds columns-selector columns-map-fn)</code><code>(rename-columns ds columns-mapping)</code></div><div class="doc"><div class="markdown"><p>Rename columns with provided old -&gt; new name map</p></div></div></div><div class="public anchor" id="var-reorder-columns"><h3>reorder-columns</h3><div class="usage"><code>(reorder-columns ds columns-selector &amp; args)</code></div><div class="doc"><div class="markdown"><p>Reorder columns using column selector(s). When column names are incomplete, the missing will be attached at the end.</p></div></div></div><div class="public anchor" id="var-replace-missing"><h3>replace-missing</h3><div class="usage"><code>(replace-missing ds)</code><code>(replace-missing ds strategy)</code><code>(replace-missing ds columns-selector strategy)</code><code>(replace-missing ds columns-selector strategy value)</code></div><div class="doc"><div class="markdown"><p>Replaces missing values. Accepts</p>
<ul>
  <li>dataset</li>
  <li>column selector, default: :all</li>
  <li>strategy, default: :nearest</li>
  <li>value (optional)</li>
  <li>single value</li>
  <li>sequence of values (cycled)</li>
  <li>function, applied on column(s) with stripped missings</li>
</ul>
<p>Strategies are:</p>
<p><code>:value</code> - replace with given value <code>:up</code> - copy values up <code>:down</code> - copy values down <code>:updown</code> - copy values up and then down for missing values at the end <code>:downup</code> - copy values down and then up for missing values at the beginning <code>:mid</code> or <code>:nearest</code> - copy values around known values <code>:midpoint</code> - use average value from previous and next non-missing <code>:lerp</code> - trying to lineary approximate values, works for numbers and datetime, otherwise applies :nearest. For numbers always results in float datatype.</p></div></div></div><div class="public anchor" id="var-reverse-map-categorical-xforms"><h3>reverse-map-categorical-xforms</h3><div class="usage"><code>(reverse-map-categorical-xforms dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset where we have converted columns from a categorical representation to either a numeric reprsentation or a one-hot representation, reverse map back to the original dataset given the reverse mapping of label-&gt;number in the column’s metadata.</p></div></div></div><div class="public anchor" id="var-right-join"><h3>right-join</h3><div class="usage"><code>(right-join ds-left ds-right columns-selector)</code><code>(right-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-row-count"><h3>row-count</h3><div class="usage"><code>(row-count dataset-or-col)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rows"><h3>rows</h3><div class="usage"><code>(rows ds)</code><code>(rows ds result-type)</code><code>(rows ds result-type options)</code></div><div class="doc"><div class="markdown"><p>Returns rows of dataset. Result type can be any of: * <code>:as-maps</code> - maps * <code>:as-double-arrays</code> - double arrays * <code>:as-seqs</code> - reader (sequence, default) * <code>:as-vecs</code> - vectors</p>
<p>If you want to elide nils in maps set <code>:nil-missing?</code> option to false (default: <code>true</code>). Another option - <code>:copying?</code> - when true row values are copied on read (default: <code>false</code>).</p></div></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select ds columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Select columns and rows.</p></div></div></div><div class="public anchor" id="var-select-columns"><h3>select-columns</h3><div class="usage"><code>(select-columns ds)</code><code>(select-columns ds columns-selector)</code><code>(select-columns ds columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Select columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-select-missing"><h3>select-missing</h3><div class="usage"><code>(select-missing ds)</code><code>(select-missing ds columns-selector)</code></div><div class="doc"><div class="markdown"><p>Select rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-select-rows"><h3>select-rows</h3><div class="usage"><code>(select-rows ds)</code><code>(select-rows ds rows-selector)</code><code>(select-rows ds rows-selector options)</code></div><div class="doc"><div class="markdown"><p>Select rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-semi-join"><h3>semi-join</h3><div class="usage"><code>(semi-join ds-left ds-right columns-selector)</code><code>(semi-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-separate-column"><h3>separate-column</h3><div class="usage"><code>(separate-column ds column)</code><code>(separate-column ds column separator)</code><code>(separate-column ds column target-columns separator)</code><code>(separate-column ds column target-columns separator conf)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-dataset-name"><h3>set-dataset-name</h3><div class="usage"><code>(set-dataset-name dataset ds-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-inference-target"><h3>set-inference-target</h3><div class="usage"><code>(set-inference-target dataset target-name-or-target-name-seq)</code></div><div class="doc"><div class="markdown"><p>Set the inference target on the column. This sets the :column-type member of the column metadata to :inference-target?.</p></div></div></div><div class="public anchor" id="var-shape"><h3>shape</h3><div class="usage"><code>(shape ds)</code></div><div class="doc"><div class="markdown"><p>Returns shape of the dataset [rows, cols]</p></div></div></div><div class="public anchor" id="var-shuffle"><h3>shuffle</h3><div class="usage"><code>(shuffle ds)</code><code>(shuffle ds options)</code></div><div class="doc"><div class="markdown"><p>Shuffle dataset (with seed)</p></div></div></div><div class="public anchor" id="var-split"><h3>split</h3><div class="usage"><code>(split ds)</code><code>(split ds split-type)</code><code>(split ds split-type options)</code></div><div class="doc"><div class="markdown"><p>Split given dataset into 2 or more (holdout) splits</p>
<p>As the result two new columns are added:</p>
<ul>
  <li><code>:$split-name</code> - with subgroup name</li>
  <li><code>:$split-id</code> - fold id/repetition id</li>
</ul>
<p><code>split-type</code> can be one of the following:</p>
<ul>
  <li><code>:kfold</code> - k-fold strategy, <code>:k</code> defines number of folds (defaults to <code>5</code>), produces <code>k</code> splits</li>
  <li><code>:bootstrap</code> - <code>:ratio</code> defines ratio of observations put into result (defaults to <code>1.0</code>), produces <code>1</code> split</li>
  <li><code>:holdout</code> - split into two parts with given ratio (defaults to <code>2/3</code>), produces <code>1</code> split</li>
  <li><code>:loo</code> - leave one out, produces the same number of splits as number of observations</li>
</ul>
<p><code>:holdout</code> can accept also probabilites or ratios and can split to more than 2 subdatasets</p>
<p>Additionally you can provide:</p>
<ul>
  <li><code>:seed</code> - for random number generator</li>
  <li><code>:repeats</code> - repeat procedure <code>:repeats</code> times</li>
  <li><code>:partition-selector</code> - same as in <code>group-by</code> for stratified splitting to reflect dataset structure in splits.</li>
  <li><code>:split-names</code> names of subdatasets different than default, ie. <code>[:train :test :split-2 ...]</code></li>
  <li><code>:split-col-name</code> - a column where name of split is stored, either <code>:train</code> or <code>:test</code> values (default: <code>:$split-name</code>)</li>
  <li><code>:split-id-col-name</code> - a column where id of the train/test pair is stored (default: <code>:$split-id</code>)</li>
  <li><code>:ratio</code> - specify a list of split ratios for <code>:holdout</code>. Need to have same size then <code>:split-names</code> (example: [0.2 0.2 0.6])</li>
</ul>
<p>Rows are shuffled before splitting.</p>
<p>In case of grouped dataset each group is processed separately.</p>
<p>See <a href="https://www.mitpressjournals.org/doi/pdf/10.1162/EVCO_a_00069">more</a></p></div></div></div><div class="public anchor" id="var-split-.3Eseq"><h3>split-&gt;seq</h3><div class="usage"><code>(split-&gt;seq ds)</code><code>(split-&gt;seq ds split-type)</code><code>(split-&gt;seq ds split-type options)</code></div><div class="doc"><div class="markdown"><p>Returns split as a sequence of train/test datasets or map of sequences (grouped dataset)</p></div></div></div><div class="public anchor" id="var-string"><h3>string</h3><div class="usage"><code>(string dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the string columns.</p></div></div></div><div class="public anchor" id="var-tail"><h3>tail</h3><div class="usage"><code>(tail ds)</code><code>(tail ds n)</code></div><div class="doc"><div class="markdown"><p>Last n rows (default 5)</p></div></div></div><div class="public anchor" id="var-target"><h3>target</h3><div class="usage"><code>(target dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the columns that have been marked as inference targets.</p></div></div></div><div class="public anchor" id="var-train-test-split"><h3>train-test-split</h3><div class="usage"><code>(train-test-split dataset options)</code><code>(train-test-split dataset)</code></div><div class="doc"><div class="markdown"><p>Probabilistically split the dataset returning a map of <code>{:train-ds :test-ds}</code>.</p>
<p>Options:</p>
<ul>
  <li><code>:randomize-dataset?</code> - When true, shuffle the dataset. In that case ‘seed’ may be  provided. Defaults to true.</li>
  <li><code>:seed</code> - when <code>:randomize-dataset?</code> is true then this can either be an  implementation of java.util.Random or an integer seed which will be used to  construct java.util.Random.</li>
  <li><code>:train-fraction</code> - Fraction of the dataset to use as training set. Defaults to  0.7.</li>
</ul></div></div></div><div class="public anchor" id="var-transform-categorical-map"><h3>transform-categorical-map</h3><div class="usage"><code>(transform-categorical-map dataset fit-data)</code></div><div class="doc"><div class="markdown"><p>Apply a categorical mapping transformation fit with fit-categorical-map.</p></div></div></div><div class="public anchor" id="var-transform-one-hot"><h3>transform-one-hot</h3><div class="usage"><code>(transform-one-hot dataset one-hot-fit-data)</code></div><div class="doc"><div class="markdown"><p>Apply a one-hot transformation to a dataset</p></div></div></div><div class="public anchor" id="var-ungroup"><h3>ungroup</h3><div class="usage"><code>(ungroup ds)</code><code>(ungroup ds options)</code></div><div class="doc"><div class="markdown"><p>Concat groups into dataset.</p>
<p>When <code>add-group-as-column</code> or <code>add-group-id-as-column</code> is set to <code>true</code> or name(s), columns with group name(s) or group id is added to the result.</p>
<p>Before joining the groups groups can be sorted by group name.</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union ds &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-unique-by"><h3>unique-by</h3><div class="usage"><code>(unique-by ds)</code><code>(unique-by ds columns-selector)</code><code>(unique-by ds columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Remove rows which contains the same data <code>column-selector</code> Select columns for uniqueness <code>strategy</code> There are 4 strategies defined to handle duplicates</p>
<p><code>:first</code> - select first row (default)  <code>:last</code> - select last row  <code>:random</code> - select random row  any function - apply function to a columns which are subject of uniqueness</p></div></div></div><div class="public anchor" id="var-unmark-group"><h3>unmark-group</h3><div class="usage"><code>(unmark-group ds)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-unroll"><h3>unroll</h3><div class="usage"><code>(unroll ds columns-selector)</code><code>(unroll ds columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Unfolds sequences stored inside a column(s), turning it into multiple columns. Opposite of <a href="scicloj.ml.dataset.html#var-fold-by">fold-by</a>. Add each of the provided columns to the set that defines the “uniqe key” of each row. Thus there will be a new row for each value inside the target column(s)’ value sequence. If you want instead to split the content of the columns into a set of new <em>columns</em>, look at <a href="scicloj.ml.dataset.html#var-separate-column">separate-column</a>. See <a href="https://scicloj.github.io/tablecloth/index.html#Unroll">https://scicloj.github.io/tablecloth/index.html#Unroll</a></p></div></div></div><div class="public anchor" id="var-update-columns"><h3>update-columns</h3><div class="usage"><code>(update-columns ds columns-map)</code><code>(update-columns ds columns-selector update-functions)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-write.21"><h3>write!</h3><div class="usage"><code>(write! dataset output-path options)</code><code>(write! dataset output-path)</code></div><div class="doc"><div class="markdown"><p>Write a dataset out to a file. Supported forms are:</p>
<pre><code class="clojure">(ds/write! test-ds "test.csv")
(ds/write! test-ds "test.tsv")
(ds/write! test-ds "test.tsv.gz")
(ds/write! test-ds "test.nippy")
(ds/write! test-ds out-stream)
</code></pre>
<p>Options:</p>
<ul>
  <li><code>:max-chars-per-column</code> - csv,tsv specific, defaults to 65536 - values longer than this will  cause an exception during serialization.</li>
  <li><code>:max-num-columns</code> - csv,tsv specific, defaults to 8192 - If the dataset has more than this number of  columns an exception will be thrown during serialization.</li>
  <li><code>:quoted-columns</code> - csv specific - sequence of columns names that you would like to always have quoted.</li>
  <li><code>:file-type</code> - Manually specify the file type. This is usually inferred from the filename but if you  pass in an output stream then you will need to specify the file type.</li>
  <li><code>:headers?</code> - if csv headers are written, defaults to true.</li>
</ul></div></div></div><div class="public anchor" id="var-write-csv.21"><h3>write-csv!</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-write-nippy.21"><h3>write-nippy!</h3><div class="usage"><code>(write-nippy! ds filename)</code></div><div class="doc"><div class="markdown"></div></div></div></div></body></html>