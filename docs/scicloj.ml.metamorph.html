<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>scicloj.ml.metamorph documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scicloj</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ml</span></div></div></li><li class="depth-3 branch"><a href="scicloj.ml.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="scicloj.ml.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-3 branch"><a href="scicloj.ml.dvc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dvc</span></div></a></li><li class="depth-3 branch current"><a href="scicloj.ml.metamorph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metamorph</span></div></a></li><li class="depth-3"><a href="scicloj.ml.try.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>try</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="scicloj.ml.metamorph.html#var--.3Earray"><div class="inner"><span>-&gt;array</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-column"><div class="inner"><span>add-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-columns"><div class="inner"><span>add-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-or-replace-column"><div class="inner"><span>add-or-replace-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-or-replace-columns"><div class="inner"><span>add-or-replace-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-or-update-column"><div class="inner"><span>add-or-update-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-aggregate"><div class="inner"><span>aggregate</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-aggregate-columns"><div class="inner"><span>aggregate-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-anti-join"><div class="inner"><span>anti-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-append-columns"><div class="inner"><span>append-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-array-column-.3Ecolumns"><div class="inner"><span>array-column-&gt;columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-as-regular-dataset"><div class="inner"><span>as-regular-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-asof-join"><div class="inner"><span>asof-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-assoc-ds"><div class="inner"><span>assoc-ds</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-assoc-metadata"><div class="inner"><span>assoc-metadata</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bind"><div class="inner"><span>bind</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3Esomething-sparse"><div class="inner"><span>bow-&gt;something-sparse</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3Esparse-array"><div class="inner"><span>bow-&gt;sparse-array</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3ESparseArray"><div class="inner"><span>bow-&gt;SparseArray</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3Etfidf"><div class="inner"><span>bow-&gt;tfidf</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-brief"><div class="inner"><span>brief</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-by-rank"><div class="inner"><span>by-rank</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-categorical-.3Enumber"><div class="inner"><span>categorical-&gt;number</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-categorical-.3Eone-hot"><div class="inner"><span>categorical-&gt;one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-clone"><div class="inner"><span>clone</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-cluster"><div class="inner"><span>cluster</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column"><div class="inner"><span>column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-.3Edataset"><div class="inner"><span>column-&gt;dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-cast"><div class="inner"><span>column-cast</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-count"><div class="inner"><span>column-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-labeled-mapseq"><div class="inner"><span>column-labeled-mapseq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-map"><div class="inner"><span>column-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-names"><div class="inner"><span>column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-values-.3Ecategorical"><div class="inner"><span>column-values-&gt;categorical</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-columns"><div class="inner"><span>columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-columns-.3Earray-column"><div class="inner"><span>columns-&gt;array-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-columns-with-missing-seq"><div class="inner"><span>columns-with-missing-seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-columnwise-concat"><div class="inner"><span>columnwise-concat</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-complete"><div class="inner"><span>complete</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-concat"><div class="inner"><span>concat</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-concat-copying"><div class="inner"><span>concat-copying</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-concat-inplace"><div class="inner"><span>concat-inplace</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-convert-types"><div class="inner"><span>convert-types</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-count-vectorize"><div class="inner"><span>count-vectorize</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-cross-join"><div class="inner"><span>cross-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-crosstab"><div class="inner"><span>crosstab</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-data-.3Edataset"><div class="inner"><span>data-&gt;dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-.3Ecategorical-xforms"><div class="inner"><span>dataset-&gt;categorical-xforms</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-.3Edata"><div class="inner"><span>dataset-&gt;data</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-.3Estr"><div class="inner"><span>dataset-&gt;str</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-name"><div class="inner"><span>dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset.3F"><div class="inner"><span>dataset?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-descriptive-stats"><div class="inner"><span>descriptive-stats</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop"><div class="inner"><span>drop</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop-columns"><div class="inner"><span>drop-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop-missing"><div class="inner"><span>drop-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop-rows"><div class="inner"><span>drop-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-empty-dataset"><div class="inner"><span>empty-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-empty-ds.3F"><div class="inner"><span>empty-ds?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-ensure-array-backed"><div class="inner"><span>ensure-array-backed</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-expand"><div class="inner"><span>expand</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-feature-ecount"><div class="inner"><span>feature-ecount</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-fill-range-replace"><div class="inner"><span>fill-range-replace</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-filter"><div class="inner"><span>filter</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-filter-column"><div class="inner"><span>filter-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-filter-dataset"><div class="inner"><span>filter-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-first"><div class="inner"><span>first</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-fold-by"><div class="inner"><span>fold-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-full-join"><div class="inner"><span>full-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-get-entry"><div class="inner"><span>get-entry</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by-.3Eindexes"><div class="inner"><span>group-by-&gt;indexes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by-column"><div class="inner"><span>group-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by-column-.3Eindexes"><div class="inner"><span>group-by-column-&gt;indexes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by-column-consumer"><div class="inner"><span>group-by-column-consumer</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-grouped.3F"><div class="inner"><span>grouped?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-groups-.3Emap"><div class="inner"><span>groups-&gt;map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-groups-.3Eseq"><div class="inner"><span>groups-&gt;seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-has-column.3F"><div class="inner"><span>has-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-head"><div class="inner"><span>head</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-induction"><div class="inner"><span>induction</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-column.3F"><div class="inner"><span>inference-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-column-names"><div class="inner"><span>inference-target-column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-ds"><div class="inner"><span>inference-target-ds</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-label-inverse-map"><div class="inner"><span>inference-target-label-inverse-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-label-map"><div class="inner"><span>inference-target-label-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-info"><div class="inner"><span>info</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inner-join"><div class="inner"><span>inner-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-intersect"><div class="inner"><span>intersect</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-join-columns"><div class="inner"><span>join-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-labels"><div class="inner"><span>labels</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-last"><div class="inner"><span>last</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-left-join"><div class="inner"><span>left-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-map-columns"><div class="inner"><span>map-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-map-rows"><div class="inner"><span>map-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-mapseq-reader"><div class="inner"><span>mapseq-reader</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-mark-as-group"><div class="inner"><span>mark-as-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-min-max-scale"><div class="inner"><span>min-max-scale</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-min-n-by-column"><div class="inner"><span>min-n-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-missing"><div class="inner"><span>missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-model"><div class="inner"><span>model</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-model-type"><div class="inner"><span>model-type</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-new-column"><div class="inner"><span>new-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-new-dataset"><div class="inner"><span>new-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-num-inference-classes"><div class="inner"><span>num-inference-classes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-order-by"><div class="inner"><span>order-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-order-column-names"><div class="inner"><span>order-column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-pivot-.3Elonger"><div class="inner"><span>pivot-&gt;longer</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-pivot-.3Ewider"><div class="inner"><span>pivot-&gt;wider</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-pmap-ds"><div class="inner"><span>pmap-ds</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-print-all"><div class="inner"><span>print-all</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-print-dataset"><div class="inner"><span>print-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-probability-distributions-.3Elabel-column"><div class="inner"><span>probability-distributions-&gt;label-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-process-group-data"><div class="inner"><span>process-group-data</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rand-nth"><div class="inner"><span>rand-nth</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-random"><div class="inner"><span>random</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-read-nippy"><div class="inner"><span>read-nippy</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-reduce-dimensions"><div class="inner"><span>reduce-dimensions</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-remove-column"><div class="inner"><span>remove-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-remove-columns"><div class="inner"><span>remove-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-remove-rows"><div class="inner"><span>remove-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rename-columns"><div class="inner"><span>rename-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-reorder-columns"><div class="inner"><span>reorder-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-replace-missing"><div class="inner"><span>replace-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-replace-missing-value"><div class="inner"><span>replace-missing-value</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-reverse-rows"><div class="inner"><span>reverse-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-right-join"><div class="inner"><span>right-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-row-at"><div class="inner"><span>row-at</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-row-count"><div class="inner"><span>row-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-row-map"><div class="inner"><span>row-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-row-mapcat"><div class="inner"><span>row-mapcat</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rows"><div class="inner"><span>rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rowvec-at"><div class="inner"><span>rowvec-at</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rowvecs"><div class="inner"><span>rowvecs</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-sample"><div class="inner"><span>sample</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-by-index"><div class="inner"><span>select-by-index</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-columns"><div class="inner"><span>select-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-columns-by-index"><div class="inner"><span>select-columns-by-index</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-missing"><div class="inner"><span>select-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-rows"><div class="inner"><span>select-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-semi-join"><div class="inner"><span>semi-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-separate-column"><div class="inner"><span>separate-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-set-dataset-name"><div class="inner"><span>set-dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-set-inference-target"><div class="inner"><span>set-inference-target</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-shape"><div class="inner"><span>shape</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-shuffle"><div class="inner"><span>shuffle</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-sort-by"><div class="inner"><span>sort-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-sort-by-column"><div class="inner"><span>sort-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-std-scale"><div class="inner"><span>std-scale</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-tail"><div class="inner"><span>tail</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-take-nth"><div class="inner"><span>take-nth</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-transform-one-hot"><div class="inner"><span>transform-one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-ungroup"><div class="inner"><span>ungroup</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unique-by"><div class="inner"><span>unique-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unique-by-column"><div class="inner"><span>unique-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unmark-group"><div class="inner"><span>unmark-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unordered-select"><div class="inner"><span>unordered-select</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unroll"><div class="inner"><span>unroll</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unroll-column"><div class="inner"><span>unroll-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update"><div class="inner"><span>update</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-column"><div class="inner"><span>update-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-columns"><div class="inner"><span>update-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-columnwise"><div class="inner"><span>update-columnwise</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-elemwise"><div class="inner"><span>update-elemwise</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-value-reader"><div class="inner"><span>value-reader</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-write.21"><div class="inner"><span>write!</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-write-nippy.21"><div class="inner"><span>write-nippy!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">scicloj.ml.metamorph</h1><div class="doc"><div class="markdown"><p>This namespace contains functions, which operate on a metamorph context. They all return the context as well.</p>
<p>So all functions in this namespace are metamorph compliant and can be placed in a metamorph pipeline.</p>
<p>Most functions here are only manipulating the dataset, which is in the ctx map under the key :metamorph/data. And they behave the same in pipeline mode :fit and :transform.</p>
<p>A few functions manipulate other keys inside the ctx map, and/or behave different in :fit and :transform.</p>
<p>This is documented per function in this form:</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>.</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>.</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>.</td>
    </tr>
  </tbody>
</table>
<p>The namespaces scicloj.ml.metamorph and scicloj.ml.dataset contain functions with the same name. But they operate on either a context map (ns metamorph) or on a dataset (ns dataset)</p>
<p>The functions in this namesspaces are re-exported from :</p>
<ul>
  <li>tablecloth.pipeline</li>
  <li>tech.v3.libs.smile.metamorph</li>
  <li>scicloj.metamorph.ml</li>
  <li>tech.v3.dataset.metamorph</li>
</ul></div></div><div class="public anchor" id="var--.3Earray"><h3>-&gt;array</h3><div class="usage"><code>(-&gt;array colname)</code><code>(-&gt;array colname datatype)</code></div><div class="doc"><div class="markdown"><p>Convert numerical column(s) to java array</p></div></div></div><div class="public anchor" id="var-add-column"><h3>add-column</h3><div class="usage"><code>(add-column column-name column)</code><code>(add-column column-name column size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or update (modify) column under <code>column-name</code>.</p>
<p><code>column</code> can be sequence of values or generator function (which gets <code>ds</code> as input).</p>
<ul>
  <li><code>ds</code> - a dataset</li>
  <li><code>column-name</code> - if it’s existing column name, column will be replaced</li>
  <li><code>column</code> - can be column (from other dataset), sequence, single value or function (taking a dataset). Too big columns are always trimmed. Too small are cycled or extended with missing values (according to <code>size-strategy</code> argument)</li>
  <li><code>size-strategy</code> (optional) - when new column is shorter than dataset row count, following strategies are applied:</li>
  <li><code>:cycle</code> - repeat data</li>
  <li><code>:na</code> - append missing values</li>
  <li><code>:strict</code> - (default) throws an exception when sizes mismatch</li>
</ul></div></div></div><div class="public anchor" id="var-add-columns"><h3>add-columns</h3><div class="usage"><code>(add-columns columns-map)</code><code>(add-columns columns-map size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or updade (modify) columns defined in <code>columns-map</code> (mapping: name -&gt; column) </p></div></div></div><div class="public anchor" id="var-add-or-replace-column"><h3>add-or-replace-column</h3><div class="usage"><code>(add-or-replace-column column-name column)</code><code>(add-or-replace-column column-name column size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-or-replace-columns"><h3>add-or-replace-columns</h3><div class="usage"><code>(add-or-replace-columns columns-map)</code><code>(add-or-replace-columns columns-map size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-or-update-column"><h3>add-or-update-column</h3><div class="usage"><code>(add-or-update-column colname column)</code><code>(add-or-update-column column)</code></div><div class="doc"><div class="markdown"><p>If column exists, replace. Else append new column.</p></div></div></div><div class="public anchor" id="var-aggregate"><h3>aggregate</h3><div class="usage"><code>(aggregate aggregator)</code><code>(aggregate aggregator options)</code></div><div class="doc"><div class="markdown"><p>Aggregate dataset by providing:</p>
<ul>
  <li>aggregation function</li>
  <li>map with column names and functions</li>
  <li>sequence of aggregation functions</li>
</ul>
<p>Aggregation functions can return: - single value - seq of values - map of values with column names</p></div></div></div><div class="public anchor" id="var-aggregate-columns"><h3>aggregate-columns</h3><div class="usage"><code>(aggregate-columns columns-aggregators)</code><code>(aggregate-columns columns-selector column-aggregators)</code><code>(aggregate-columns columns-selector column-aggregators options)</code></div><div class="doc"><div class="markdown"><p>Aggregates each column separately</p></div></div></div><div class="public anchor" id="var-anti-join"><h3>anti-join</h3><div class="usage"><code>(anti-join ds-right columns-selector)</code><code>(anti-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append &amp; args)</code></div><div class="doc"><div class="markdown"><p>Concats columns of several datasets</p></div></div></div><div class="public anchor" id="var-append-columns"><h3>append-columns</h3><div class="usage"><code>(append-columns column-seq)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-array-column-.3Ecolumns"><h3>array-column-&gt;columns</h3><div class="usage"><code>(array-column-&gt;columns src-column opts)</code><code>(array-column-&gt;columns src-column)</code></div><div class="doc"><div class="markdown"><p>Converts a column of type java array into several columns, one for each element of the array of all rows. The source column is dropped afterwards. The function assumes that arrays in all rows have same type and length and are numeric.</p>
<p><code>ds</code> Datset to operate on. <code>src-column</code> The (array) column to convert <code>opts</code> can contain:  <code>prefix</code> newly created column will get prefix before column number</p></div></div></div><div class="public anchor" id="var-as-regular-dataset"><h3>as-regular-dataset</h3><div class="usage"><code>(as-regular-dataset)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-asof-join"><h3>asof-join</h3><div class="usage"><code>(asof-join ds-right columns-selector)</code><code>(asof-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-assoc-ds"><h3>assoc-ds</h3><div class="usage"><code>(assoc-ds cname cdata &amp; args)</code></div><div class="doc"><div class="markdown"><p>If dataset is not nil, calls <code>clojure.core/assoc</code>. Else creates a new empty dataset and then calls <code>clojure.core/assoc</code>. Guaranteed to return a dataset (unlike assoc).</p></div></div></div><div class="public anchor" id="var-assoc-metadata"><h3>assoc-metadata</h3><div class="usage"><code>(assoc-metadata filter-fn-or-ds k v &amp; args)</code></div><div class="doc"><div class="markdown"><p>Set metadata across a set of columns.</p></div></div></div><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-bow-.3Esomething-sparse"><h3>bow-&gt;something-sparse</h3><div class="usage"><code>(bow-&gt;something-sparse bow-col indices-col bow-&gt;sparse-fn options)</code></div><div class="doc"><div class="markdown"><p>Converts a bag-of-word column <code>bow-col</code> to a sparse data column <code>indices-col</code>.  The exact transformation to the sparse representtaion is given by <code>bow-&gt;sparse-fn</code></p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>:scicloj.ml.smile.metamorph/bow-&gt;sparse-vocabulary</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-bow-.3Esparse-array"><h3>bow-&gt;sparse-array</h3><div class="usage"><code>(bow-&gt;sparse-array bow-col indices-col options)</code><code>(bow-&gt;sparse-array bow-col indices-col)</code></div><div class="doc"><div class="markdown"><p>Converts a bag-of-word column <code>bow-col</code> to sparse indices column <code>indices-col</code>, as needed by the Maxent model. <code>Options</code> can be of:</p>
<p><code>create-vocab-fn</code> A function which converts the bow map to a list of tokens.  Defaults to scicloj.ml.smile.nlp/create-vocab-all</p>
<p>The sparse data is represented as <code>primitive int arrays</code>, of which entries are the indices against the vocabulary of the present tokens.</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>:scicloj.ml.smile.metamorph/bow-&gt;sparse-vocabulary</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-bow-.3ESparseArray"><h3>bow-&gt;SparseArray</h3><div class="usage"><code>(bow-&gt;SparseArray bow-col indices-col options)</code><code>(bow-&gt;SparseArray bow-col indices-col)</code></div><div class="doc"><div class="markdown"><p>Converts a bag-of-word column <code>bow-col</code> to sparse indices column <code>indices-col</code>,  as needed by the discrete naive bayes model.</p>
<p><code>Options</code> can be of:</p>
<p><code>create-vocab-fn</code> A function which converts the bow map to a list of tokens.  Defaults to scicloj.ml.smile.nlp/create-vocab-all</p>
<p>The sparse data is represented as <code>smile.util.SparseArray</code>.</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>:scicloj.ml.smile.metamorph/bow-&gt;sparse-vocabulary</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-bow-.3Etfidf"><h3>bow-&gt;tfidf</h3><div class="usage"><code>(bow-&gt;tfidf bow-column tfidf-column options)</code></div><div class="doc"><div class="markdown"><p>Calculates the tfidf score from bag-of-words (as token frequency maps)  in column <code>bow-column</code> and stores them in a new column <code>tfid-column</code> as maps of token-&gt;tfidf-score.</p>
<p>It calculates a global term-frequency map in :fit and reuses it in :transform</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>none</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-brief"><h3>brief</h3><div class="usage"><code>(brief options)</code><code>(brief)</code></div><div class="doc"><div class="markdown"><p>Get a brief description, in mapseq form of a dataset. A brief description is the mapseq form of descriptive stats.</p></div></div></div><div class="public anchor" id="var-by-rank"><h3>by-rank</h3><div class="usage"><code>(by-rank columns-selector rank-predicate)</code><code>(by-rank columns-selector rank-predicate options)</code></div><div class="doc"><div class="markdown"><p>Select rows using <code>rank</code> on a column, ties are resolved using <code>:dense</code> method.</p>
<p>See <a href="https://www.rdocumentation.org/packages/base/versions/3.6.1/topics/rank">R docs</a>. Rank uses 0 based indexing.</p>
<p>Possible <code>:ties</code> strategies: <code>:average</code>, <code>:first</code>, <code>:last</code>, <code>:random</code>, <code>:min</code>, <code>:max</code>, <code>:dense</code>. <code>:dense</code> is the same as in <code>data.table::frank</code> from R</p>
<p><code>:desc?</code> set to true (default) order descending before calculating rank</p></div></div></div><div class="public anchor" id="var-categorical-.3Enumber"><h3>categorical-&gt;number</h3><div class="usage"><code>(categorical-&gt;number filter-fn-or-ds)</code><code>(categorical-&gt;number filter-fn-or-ds table-args)</code><code>(categorical-&gt;number filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert columns into a discrete , numeric representation See tech.v3.dataset.categorical/fit-categorical-map.</p></div></div></div><div class="public anchor" id="var-categorical-.3Eone-hot"><h3>categorical-&gt;one-hot</h3><div class="usage"><code>(categorical-&gt;one-hot filter-fn-or-ds)</code><code>(categorical-&gt;one-hot filter-fn-or-ds table-args)</code><code>(categorical-&gt;one-hot filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert string columns to numeric columns. See tech.v3.dataset.categorical/fit-one-hot</p></div></div></div><div class="public anchor" id="var-clone"><h3>clone</h3><div class="usage"><code>(clone)</code></div><div class="doc"><div class="markdown"><p>Clone an object. Can clone anything convertible to a reader.</p></div></div></div><div class="public anchor" id="var-cluster"><h3>cluster</h3><div class="usage"><code>(cluster clustering-method clustering-method-args target-column)</code></div><div class="doc"><div class="markdown"><p>Metamorph transformer, which clusters the data and creates a new column with the cluster id.</p>
<p><code>clustering-method</code> can be any of:</p>
<ul>
  <li>:spectral</li>
  <li>:dbscan</li>
  <li>:k-means</li>
  <li>:mec</li>
  <li>:clarans</li>
  <li>:g-means</li>
  <li>:lloyd</li>
  <li>:x-means</li>
  <li>:deterministic-annealing</li>
  <li>:denclue</li>
</ul>
<p>The <code>clustering-args</code> is a vector with the positional arguments for each cluster function, as documented here: <a href="https://cljdoc.org/d/generateme/fastmath/2.1.5/api/fastmath.clustering">https://cljdoc.org/d/generateme/fastmath/2.1.5/api/fastmath.clustering</a> (but minus the <code>data</code> argument, which will be passed in automatically)</p>
<p>The cluster id of each row gets written to the column in <code>target-column</code></p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Calculates cluster centers of the rows dataset at key <code>:metamorph/data</code> and stores them in ctx under key at <code>:metamorph/id</code>. Adds as wll column in <code>target-column</code> with cluster centers into the dataset.</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads cluster centers from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads cluster centers to use from ctx at key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores cluster centers in ctx under key in <code>:metamorph/id</code>.</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-column"><h3>column</h3><div class="usage"><code>(column colname)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-.3Edataset"><h3>column-&gt;dataset</h3><div class="usage"><code>(column-&gt;dataset colname transform-fn options)</code><code>(column-&gt;dataset colname transform-fn)</code></div><div class="doc"><div class="markdown"><p>Transform a column into a sequence of maps using transform-fn. Return dataset created out of the sequence of maps.</p></div></div></div><div class="public anchor" id="var-column-cast"><h3>column-cast</h3><div class="usage"><code>(column-cast colname datatype)</code></div><div class="doc"><div class="markdown"><p>Cast a column to a new datatype. This is never a lazy operation. If the old and new datatypes match and no cast-fn is provided then dtype/clone is called on the column.</p>
<p>colname may be a scalar or a tuple of [src-col dst-col].</p>
<p>datatype may be a datatype enumeration or a tuple of [datatype cast-fn] where cast-fn may return either a new value, :tech.v3.dataset/missing, or :tech.v3.dataset/parse-failure. Exceptions are propagated to the caller. The new column has at least the existing missing set (if no attempt returns :missing or :cast-failure). :cast-failure means the value gets added to metadata key :unparsed-data and the index gets added to :unparsed-indexes.</p>
<p>If the existing datatype is string, then tech.v3.datatype.column/parse-column is called.</p>
<p>Casts between numeric datatypes need no cast-fn but one may be provided. Casts to string need no cast-fn but one may be provided. Casts from string to anything will call tech.v3.dataset.column/parse-column.</p></div></div></div><div class="public anchor" id="var-column-count"><h3>column-count</h3><div class="usage"><code>(column-count)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-labeled-mapseq"><h3>column-labeled-mapseq</h3><div class="usage"><code>(column-labeled-mapseq value-colname-seq)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a sequence of maps where several columns are all stored  in a :value key and a :label key contains a column name. Used for quickly creating  timeseries or scatterplot labeled graphs. Returns a lazy sequence, not a reader!</p>
<p>See also <code>columnwise-concat</code></p>
<p>Return a sequence of maps with</p>
<pre><code class="clojure">  {... - columns not in colname-seq
   :value - value from one of the value columns
   :label - name of the column the value came from
  }
</code></pre></div></div></div><div class="public anchor" id="var-column-map"><h3>column-map</h3><div class="usage"><code>(column-map result-colname map-fn res-dtype-or-opts filter-fn-or-ds)</code><code>(column-map result-colname map-fn filter-fn-or-ds)</code><code>(column-map result-colname map-fn)</code></div><div class="doc"><div class="markdown"><p>Produce a new (or updated) column as the result of mapping a fn over columns. This  function is never lazy - all results are immediately calculated.</p>
<ul>
  <li><code>dataset</code> - dataset.</li>
  <li><code>result-colname</code> - Name of new (or existing) column.</li>
  <li><code>map-fn</code> - function to map over columns. Same rules as <code>tech.v3.datatype/emap</code>.</li>
  <li><code>res-dtype-or-opts</code> - If not given result is scanned to infer missing and datatype.  If using an option map, options are described below.</li>
  <li><code>filter-fn-or-ds</code> - A dataset, a sequence of columns, or a <code>tech.v3.datasets/column-filters</code>  column filter function. Defaults to all the columns of the existing dataset.</li>
</ul>
<p>Returns a new dataset with a new or updated column.</p>
<p>Options:</p>
<ul>
  <li><code>:datatype</code> - Set the dataype of the result column. If not given result is scanned  to infer result datatype and missing set.</li>
  <li><code>:missing-fn</code> - if given, columns are first passed to missing-fn as a sequence and  this dictates the missing set. Else the missing set is by scanning the results  during the inference process. See <code>tech.v3.dataset.column/union-missing-sets</code> and  <code>tech.v3.dataset.column/intersect-missing-sets</code> for example functions to pass in  here.</li>
</ul>
<p>Examples:</p>
<pre><code class="clojure"><br />  ;;From the tests --

  (let [testds (ds/-&gt;dataset [{:a 1.0 :b 2.0} {:a 3.0 :b 5.0} {:a 4.0 :b nil}])]
    ;;result scanned for both datatype and missing set
    (is (= (vec [3.0 6.0 nil])
           (:b2 (ds/column-map testds :b2 #(when % (inc %)) [:b]))))
    ;;result scanned for missing set only.  Result used in-place.
    (is (= (vec [3.0 6.0 nil])
           (:b2 (ds/column-map testds :b2 #(when % (inc %))
                               {:datatype :float64} [:b]))))
    ;;Nothing scanned at all.
    (is (= (vec [3.0 6.0 nil])
           (:b2 (ds/column-map testds :b2 #(inc %)
                               {:datatype :float64
                                :missing-fn ds-col/union-missing-sets} [:b]))))
    ;;Missing set scanning causes NPE at inc.
    (is (thrown? Throwable
                 (ds/column-map testds :b2 #(inc %)
                                {:datatype :float64}
                                [:b]))))

  ;;Ad-hoc repl --

user&gt; (require '[tech.v3.dataset :as ds]))
nil
user&gt; (def ds (ds/-&gt;dataset "test/data/stocks.csv"))
#'user/ds
user&gt; (ds/head ds)
test/data/stocks.csv [5 3]:

| symbol |       date | price |
|--------|------------|-------|
|   MSFT | 2000-01-01 | 39.81 |
|   MSFT | 2000-02-01 | 36.35 |
|   MSFT | 2000-03-01 | 43.22 |
|   MSFT | 2000-04-01 | 28.37 |
|   MSFT | 2000-05-01 | 25.45 |
user&gt; (-&gt; (ds/column-map ds "price^2" #(* % %) ["price"])
          (ds/head))
test/data/stocks.csv [5 4]:

| symbol |       date | price |   price^2 |
|--------|------------|-------|-----------|
|   MSFT | 2000-01-01 | 39.81 | 1584.8361 |
|   MSFT | 2000-02-01 | 36.35 | 1321.3225 |
|   MSFT | 2000-03-01 | 43.22 | 1867.9684 |
|   MSFT | 2000-04-01 | 28.37 |  804.8569 |
|   MSFT | 2000-05-01 | 25.45 |  647.7025 |



user&gt; (def ds1 (ds/-&gt;dataset [{:a 1} {:b 2.0} {:a 2 :b 3.0}]))
#'user/ds1
user&gt; ds1
_unnamed [3 2]:

|  :b | :a |
|----:|---:|
|     |  1 |
| 2.0 |    |
| 3.0 |  2 |
user&gt; (ds/column-map ds1 :c (fn [a b]
                              (when (and a b)
                                (+ (double a) (double b))))
                     [:a :b])
_unnamed [3 3]:

|  :b | :a |  :c |
|----:|---:|----:|
|     |  1 |     |
| 2.0 |    |     |
| 3.0 |  2 | 5.0 |
user&gt; (ds/missing (*1 :c))
{0,1}
</code></pre></div></div></div><div class="public anchor" id="var-column-names"><h3>column-names</h3><div class="usage"><code>(column-names)</code><code>(column-names columns-selector)</code><code>(column-names columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Returns column names, given a selector.  Columns-selector can be one of the following:</p>
<ul>
  <li>:all keyword - selects all columns</li>
  <li>column name - for single column</li>
  <li>sequence of column names - for collection of columns</li>
  <li>regex - to apply pattern on column names or datatype</li>
  <li>filter predicate - to filter column names or datatype</li>
  <li>type namespaced keyword for specific datatype or group of datatypes</li>
</ul>
<p>Column name can be anything.</p>
<p>column-names function returns names according to columns-selector  and optional meta-field. meta-field is one of the following:</p>
<ul>
  <li><code>:name</code> (default) - to operate on column names</li>
  <li><code>:datatype</code> - to operated on column types</li>
  <li><code>:all</code> - if you want to process all metadata</li>
</ul>
<p>Datatype groups are:</p>
<ul>
  <li><code>:type/numerical</code> - any numerical type</li>
  <li><code>:type/float</code> - floating point number (:float32 and :float64)</li>
  <li><code>:type/integer</code> - any integer</li>
  <li><code>:type/datetime</code> - any datetime type</li>
</ul>
<p>If qualified keyword starts with :!type, complement set is used.</p></div></div></div><div class="public anchor" id="var-column-values-.3Ecategorical"><h3>column-values-&gt;categorical</h3><div class="usage"><code>(column-values-&gt;categorical src-column)</code></div><div class="doc"><div class="markdown"><p>Given a column encoded via either string-&gt;number or one-hot, reverse map to the a sequence of the original string column values. In the case of one-hot mappings, src-column must be the original column name before the one-hot map</p></div></div></div><div class="public anchor" id="var-columns"><h3>columns</h3><div class="usage"><code>(columns)</code><code>(columns result-type)</code></div><div class="doc"><div class="markdown"><p>Returns columns of dataset. Result type can be any of: * <code>:as-map</code> * <code>:as-double-arrays</code> * <code>:as-seqs</code></p></div></div></div><div class="public anchor" id="var-columns-.3Earray-column"><h3>columns-&gt;array-column</h3><div class="usage"><code>(columns-&gt;array-column column-selector new-column)</code></div><div class="doc"><div class="markdown"><p>Converts several columns to a single column of type array.  The src columns are dropped afterwards.</p>
<p><code>ds</code> Dataset to operate on. <code>column-selector</code> anything supported by <a href="scicloj.ml.metamorph.html#var-select-columns">select-columns</a> <code>new-column</code> new column to create</p></div></div></div><div class="public anchor" id="var-columns-with-missing-seq"><h3>columns-with-missing-seq</h3><div class="usage"><code>(columns-with-missing-seq)</code></div><div class="doc"><div class="markdown"><p>Return a sequence of:</p>
<pre><code class="clojure">  {:column-name column-name
   :missing-count missing-count
  }
</code></pre>
<p>or nil of no columns are missing data.</p></div></div></div><div class="public anchor" id="var-columnwise-concat"><h3>columnwise-concat</h3><div class="usage"><code>(columnwise-concat colnames options)</code><code>(columnwise-concat colnames)</code></div><div class="doc"><div class="markdown"><p>Given a dataset and a list of columns, produce a new dataset with  the columns concatenated to a new column with a :column column indicating  which column the original value came from. Any columns not mentioned in the  list of columns are duplicated.</p>
<p>Example:</p>
<pre><code class="clojure">user&gt; (-&gt; [{:a 1 :b 2 :c 3 :d 1} {:a 4 :b 5 :c 6 :d 2}]
          (ds/-&gt;dataset)
          (ds/columnwise-concat [:c :a :b]))
null [6 3]:

| :column | :value | :d |
|---------+--------+----|
|      :c |      3 |  1 |
|      :c |      6 |  2 |
|      :a |      1 |  1 |
|      :a |      4 |  2 |
|      :b |      2 |  1 |
|      :b |      5 |  2 |
</code></pre>
<p>Options:</p>
<p>value-column-name - defaults to :value  colname-column-name - defaults to :column</p></div></div></div><div class="public anchor" id="var-complete"><h3>complete</h3><div class="usage"><code>(complete columns-selector &amp; args)</code></div><div class="doc"><div class="markdown"><p>TidyR complete.</p>
<p>Fills a dataset with all possible combinations of selected columns. When a given combination doesn’t exist, missing values are created.</p></div></div></div><div class="public anchor" id="var-concat"><h3>concat</h3><div class="usage"><code>(concat &amp; args)</code></div><div class="doc"><div class="markdown"><p>Joins rows from other datasets</p></div></div></div><div class="public anchor" id="var-concat-copying"><h3>concat-copying</h3><div class="usage"><code>(concat-copying &amp; args)</code></div><div class="doc"><div class="markdown"><p>Joins rows from other datasets via a copy of data</p></div></div></div><div class="public anchor" id="var-concat-inplace"><h3>concat-inplace</h3><div class="usage"><code>(concat-inplace &amp; args)</code><code>(concat-inplace)</code></div><div class="doc"><div class="markdown"><p>Concatenate datasets in place. Respects missing values. Datasets must all have the same columns. Result column datatypes will be a widening cast of the datatypes.</p></div></div></div><div class="public anchor" id="var-convert-types"><h3>convert-types</h3><div class="usage"><code>(convert-types coltype-map-or-columns-selector)</code><code>(convert-types columns-selector new-types)</code></div><div class="doc"><div class="markdown"><p>Convert type of the column to the other type.</p></div></div></div><div class="public anchor" id="var-count-vectorize"><h3>count-vectorize</h3><div class="usage"><code>(count-vectorize text-col bow-col options)</code><code>(count-vectorize text-col bow-col)</code></div><div class="doc"><div class="markdown"><p>Transforms the text column <code>text-col</code> into a map of token frequencies in column <code>bow-col</code></p>
<p><code>options</code> can be any of</p>
<ul>
  <li><code>text-&gt;bow-fn</code> A functions which takes as input a text as string and options.  The default is <code>nlp/default-text-&gt;bow</code></li>
</ul>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>none</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-cross-join"><h3>cross-join</h3><div class="usage"><code>(cross-join ds-right)</code><code>(cross-join ds-right columns-selector)</code><code>(cross-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Cross product from selected columns</p></div></div></div><div class="public anchor" id="var-crosstab"><h3>crosstab</h3><div class="usage"><code>(crosstab row-selector col-selector)</code><code>(crosstab row-selector col-selector options)</code></div><div class="doc"><div class="markdown"><p>Cross tabulation of two sets of columns.</p>
<p>Creates grouped dataset by [row-selector, col-selector] pairs and calls aggregation on each group.</p>
<p>Options:</p>
<ul>
  <li>pivot? - create pivot table or just flat structure (default: true)</li>
  <li>replace-missing? - replace missing values? (default: true)</li>
  <li>missing-value - a missing value (default: 0)</li>
  <li>aggregator - aggregating function (default: row-count)</li>
  <li>marginal-rows, marginal-cols - adds row and/or cols, it’s a sum if true. Can be a custom fn.</li>
</ul></div></div></div><div class="public anchor" id="var-data-.3Edataset"><h3>data-&gt;dataset</h3><div class="usage"><code>(data-&gt;dataset)</code></div><div class="doc"><div class="markdown"><p>Convert a data-ized dataset created via dataset-&gt;data back into a full dataset</p></div></div></div><div class="public anchor" id="var-dataset-.3Ecategorical-xforms"><h3>dataset-&gt;categorical-xforms</h3><div class="usage"><code>(dataset-&gt;categorical-xforms)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a map of column-name-&gt;xform information.</p></div></div></div><div class="public anchor" id="var-dataset-.3Edata"><h3>dataset-&gt;data</h3><div class="usage"><code>(dataset-&gt;data)</code></div><div class="doc"><div class="markdown"><p>Convert a dataset to a pure clojure datastructure. Returns a map with two keys: {:metadata :columns}. :columns is a vector of column definitions appropriate for passing directly back into new-dataset. A column definition in this case is a map of {:name :missing :data :metadata}.</p></div></div></div><div class="public anchor" id="var-dataset-.3Estr"><h3>dataset-&gt;str</h3><div class="usage"><code>(dataset-&gt;str options)</code><code>(dataset-&gt;str)</code></div><div class="doc"><div class="markdown"><p>Convert a dataset to a string. Prints a single line header and then calls dataset-data-&gt;str.</p>
<p>For options documentation see dataset-data-&gt;str.</p></div></div></div><div class="public anchor" id="var-dataset-name"><h3>dataset-name</h3><div class="usage"><code>(dataset-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-dataset.3F"><h3>dataset?</h3><div class="usage"><code>(dataset?)</code></div><div class="doc"><div class="markdown"><p>Is <code>ds</code> a <code>dataset</code> type?</p></div></div></div><div class="public anchor" id="var-descriptive-stats"><h3>descriptive-stats</h3><div class="usage"><code>(descriptive-stats)</code><code>(descriptive-stats options)</code></div><div class="doc"><div class="markdown"><p>Get descriptive statistics across the columns of the dataset. In addition to the standard stats. Options: :stat-names - defaults to (remove #{:values :num-distinct-values}  (all-descriptive-stats-names)) :n-categorical-values - Number of categorical values to report in the ‘values’  field. Defaults to 21.</p></div></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference ds-right)</code><code>(difference ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-drop"><h3>drop</h3><div class="usage"><code>(drop columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Drop columns and rows.</p></div></div></div><div class="public anchor" id="var-drop-columns"><h3>drop-columns</h3><div class="usage"><code>(drop-columns)</code><code>(drop-columns columns-selector)</code><code>(drop-columns columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Drop columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-drop-missing"><h3>drop-missing</h3><div class="usage"><code>(drop-missing)</code><code>(drop-missing columns-selector)</code></div><div class="doc"><div class="markdown"><p>Drop rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-drop-rows"><h3>drop-rows</h3><div class="usage"><code>(drop-rows)</code><code>(drop-rows rows-selector)</code><code>(drop-rows rows-selector options)</code></div><div class="doc"><div class="markdown"><p>Drop rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-empty-dataset"><h3>empty-dataset</h3><div class="usage"><code>(empty-dataset)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-empty-ds.3F"><h3>empty-ds?</h3><div class="usage"><code>(empty-ds?)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ensure-array-backed"><h3>ensure-array-backed</h3><div class="usage"><code>(ensure-array-backed options)</code><code>(ensure-array-backed)</code></div><div class="doc"><div class="markdown"><p>Ensure the column data in the dataset is stored in pure java arrays. This is sometimes necessary for interop with other libraries and this operation will force any lazy computations to complete. This also clears the missing set for each column and writes the missing values to the new arrays.</p>
<p>Columns that are already array backed and that have no missing values are not changed and retuned.</p>
<p>The postcondition is that dtype/-&gt;array will return a java array in the appropriate datatype for each column.</p>
<p>Options:</p>
<ul>
  <li><code>:unpack?</code> - unpack packed datetime types. Defaults to true</li>
</ul></div></div></div><div class="public anchor" id="var-expand"><h3>expand</h3><div class="usage"><code>(expand columns-selector &amp; args)</code></div><div class="doc"><div class="markdown"><p>TidyR expand.</p>
<p>Creates all possible combinations of selected columns.</p></div></div></div><div class="public anchor" id="var-feature-ecount"><h3>feature-ecount</h3><div class="usage"><code>(feature-ecount)</code></div><div class="doc"><div class="markdown"><p>Number of feature columns. Feature columns are columns that are not inference targets.</p></div></div></div><div class="public anchor" id="var-fill-range-replace"><h3>fill-range-replace</h3><div class="usage"><code>(fill-range-replace colname max-span)</code><code>(fill-range-replace colname max-span missing-strategy)</code><code>(fill-range-replace colname max-span missing-strategy missing-value)</code></div><div class="doc"><div class="markdown"><p>Fill missing up with lacking values. Accepts * dataset * column name * expected step (max-span, milliseconds in case of datetime column) * (optional) missing-strategy - how to replace missing, default :down (set to nil if none) * (optional) missing-value - optional value for replace missing</p></div></div></div><div class="public anchor" id="var-filter"><h3>filter</h3><div class="usage"><code>(filter predicate)</code></div><div class="doc"><div class="markdown"><p>dataset-&gt;dataset transformation. Predicate is passed a map of colname-&gt;column-value.</p></div></div></div><div class="public anchor" id="var-filter-column"><h3>filter-column</h3><div class="usage"><code>(filter-column colname predicate)</code><code>(filter-column colname)</code></div><div class="doc"><div class="markdown"><p>Filter a given column by a predicate. Predicate is passed column values. If predicate is <em>not</em> an instance of Ifn it is treated as a value and will be used as if the predicate is #(= value %).</p>
<p>The 2-arity form of this function reads the column as a boolean reader so for instance numeric 0 values are false in that case as are Double/NaN, Float/NaN. Objects are only false if nil?.</p>
<p>Returns a dataset.</p></div></div></div><div class="public anchor" id="var-filter-dataset"><h3>filter-dataset</h3><div class="usage"><code>(filter-dataset filter-fn-or-ds)</code></div><div class="doc"><div class="markdown"><p>Filter the columns of the dataset returning a new dataset. This pathway is designed to work with the tech.v3.dataset.column-filters namespace.</p>
<ul>
  <li>If filter-fn-or-ds is a dataset, it is returned.</li>
  <li>If filter-fn-or-ds is sequential, then select-columns is called.</li>
  <li>If filter-fn-or-ds is :all, all columns are returned</li>
  <li>If filter-fn-or-ds is an instance of IFn, the dataset is passed into it.</li>
</ul></div></div></div><div class="public anchor" id="var-first"><h3>first</h3><div class="usage"><code>(first)</code></div><div class="doc"><div class="markdown"><p>First row</p></div></div></div><div class="public anchor" id="var-fold-by"><h3>fold-by</h3><div class="usage"><code>(fold-by columns-selector)</code><code>(fold-by columns-selector folding-function)</code></div><div class="doc"><div class="markdown"><p>Group-by and pack columns into vector - the output data set has a row for each unique combination of the provided columns while each remaining column has its valu(es) collected into a vector, similar to how clojure.core/group-by works. See <a href="https://scicloj.github.io/tablecloth/index.html#Fold-by">https://scicloj.github.io/tablecloth/index.html#Fold-by</a></p></div></div></div><div class="public anchor" id="var-full-join"><h3>full-join</h3><div class="usage"><code>(full-join ds-right columns-selector)</code><code>(full-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Join keeping all rows</p></div></div></div><div class="public anchor" id="var-get-entry"><h3>get-entry</h3><div class="usage"><code>(get-entry column row)</code></div><div class="doc"><div class="markdown"><p>Returns a single value from given column and row</p></div></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><div class="usage"><code>(group-by grouping-selector)</code><code>(group-by grouping-selector options)</code></div><div class="doc"><div class="markdown"><p>Group dataset by:</p>
<ul>
  <li>column name</li>
  <li>list of columns</li>
  <li>map of keys and row indexes</li>
  <li>function getting map of values</li>
</ul>
<p>Options are:</p>
<ul>
  <li>select-keys - when grouping is done by function, you can limit fields to a <code>select-keys</code> seq.</li>
  <li>result-type - return results as dataset (<code>:as-dataset</code>, default) or as map of datasets (<code>:as-map</code>) or as map of row indexes (<code>:as-indexes</code>) or as sequence of (sub)datasets</li>
  <li>other parameters which are passed to <code>dataset</code> fn</li>
</ul>
<p>When dataset is returned, meta contains <code>:grouped?</code> set to true. Columns in dataset:</p>
<ul>
  <li>name - group name</li>
  <li>group-id - id of the group (int)</li>
  <li>data - group as dataset</li>
</ul></div></div></div><div class="public anchor" id="var-group-by-.3Eindexes"><h3>group-by-&gt;indexes</h3><div class="usage"><code>(group-by-&gt;indexes key-fn options)</code><code>(group-by-&gt;indexes key-fn)</code></div><div class="doc"><div class="markdown"><p>(Non-lazy) - Group a dataset and return a map of key-fn-value-&gt;indexes where indexes is an in-order contiguous group of indexes.</p></div></div></div><div class="public anchor" id="var-group-by-column"><h3>group-by-column</h3><div class="usage"><code>(group-by-column colname options)</code><code>(group-by-column colname)</code></div><div class="doc"><div class="markdown"><p>Return a map of column-value-&gt;dataset.</p>
<ul>
  <li><code>:group-by-finalizer</code> - when provided this is run on each dataset immediately after the  rows are selected. This can be used to immediately perform a reduction on each new  dataset which is faster than doing it in a separate run.</li>
</ul></div></div></div><div class="public anchor" id="var-group-by-column-.3Eindexes"><h3>group-by-column-&gt;indexes</h3><div class="usage"><code>(group-by-column-&gt;indexes colname options)</code><code>(group-by-column-&gt;indexes colname)</code></div><div class="doc"><div class="markdown"><p>(Non-lazy) - Group a dataset by a column return a map of column-val-&gt;indexes where indexes is an in-order contiguous group of indexes.</p>
<p>Options are passed into dtype’s arggroup method.</p></div></div></div><div class="public anchor" id="var-group-by-column-consumer"><h3>group-by-column-consumer</h3><div class="usage"><code>(group-by-column-consumer cname)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-grouped.3F"><h3>grouped?</h3><div class="usage"><code>(grouped?)</code></div><div class="doc"><div class="markdown"><p>Is <code>dataset</code> represents grouped dataset (result of <code>group-by</code>)?</p></div></div></div><div class="public anchor" id="var-groups-.3Emap"><h3>groups-&gt;map</h3><div class="usage"><code>(groups-&gt;map)</code></div><div class="doc"><div class="markdown"><p>Convert grouped dataset to the map of groups</p></div></div></div><div class="public anchor" id="var-groups-.3Eseq"><h3>groups-&gt;seq</h3><div class="usage"><code>(groups-&gt;seq)</code></div><div class="doc"><div class="markdown"><p>Convert grouped dataset to seq of the groups</p></div></div></div><div class="public anchor" id="var-has-column.3F"><h3>has-column?</h3><div class="usage"><code>(has-column? column-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-head"><h3>head</h3><div class="usage"><code>(head)</code><code>(head n)</code></div><div class="doc"><div class="markdown"><p>First n rows (default 5)</p></div></div></div><div class="public anchor" id="var-induction"><h3>induction</h3><div class="usage"><code>(induction induct-fn &amp; args)</code></div><div class="doc"><div class="markdown"><p>Given a dataset and a function from dataset-&gt;row produce a new dataset.  The produced row will be merged with the current row and then added to the  dataset.</p>
<p>Options are same as the options used for <a href="null">-&gt;dataset</a> in order for the  user to control the parsing of the return values of <code>induct-fn</code>.  A new dataset is returned.</p>
<p>Example:</p>
<pre><code class="clojure">user&gt; (def ds (ds/-&gt;dataset {:a [0 1 2 3] :b [1 2 3 4]}))
#'user/ds
user&gt; ds
_unnamed [4 2]:

| :a | :b |
|---:|---:|
|  0 |  1 |
|  1 |  2 |
|  2 |  3 |
|  3 |  4 |
user&gt; (ds/induction ds (fn [ds]
                         {:sum-of-previous-row (dfn/sum (ds/rowvec-at ds -1))
                          :sum-a (dfn/sum (ds :a))
                          :sum-b (dfn/sum (ds :b))}))
_unnamed [4 5]:

| :a | :b | :sum-b | :sum-a | :sum-of-previous-row |
|---:|---:|-------:|-------:|---------------------:|
|  0 |  1 |    0.0 |    0.0 |                  0.0 |
|  1 |  2 |    1.0 |    0.0 |                  1.0 |
|  2 |  3 |    3.0 |    1.0 |                  5.0 |
|  3 |  4 |    6.0 |    3.0 |                 14.0 |
</code></pre></div></div></div><div class="public anchor" id="var-inference-column.3F"><h3>inference-column?</h3><div class="usage"><code>(inference-column?)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inference-target-column-names"><h3>inference-target-column-names</h3><div class="usage"><code>(inference-target-column-names)</code></div><div class="doc"><div class="markdown"><p>Return the names of the columns that are inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-ds"><h3>inference-target-ds</h3><div class="usage"><code>(inference-target-ds)</code></div><div class="doc"><div class="markdown"><p>Given a dataset return reverse-mapped inference target columns or nil in the case where there are no inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-label-inverse-map"><h3>inference-target-label-inverse-map</h3><div class="usage"><code>(inference-target-label-inverse-map &amp; args)</code></div><div class="doc"><div class="markdown"><p>Given options generated during ETL operations and annotated with :label-columns sequence container 1 label column, generate a reverse map that maps from a dataset value back to the label that generated that value.</p></div></div></div><div class="public anchor" id="var-inference-target-label-map"><h3>inference-target-label-map</h3><div class="usage"><code>(inference-target-label-map &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-info"><h3>info</h3><div class="usage"><code>(info)</code><code>(info result-type)</code></div><div class="doc"><div class="markdown"><p>Returns a statistcial information about the columns of a dataset. <code>result-type</code> can be :descriptive or :columns</p></div></div></div><div class="public anchor" id="var-inner-join"><h3>inner-join</h3><div class="usage"><code>(inner-join ds-right columns-selector)</code><code>(inner-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-intersect"><h3>intersect</h3><div class="usage"><code>(intersect ds-right)</code><code>(intersect ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-join-columns"><h3>join-columns</h3><div class="usage"><code>(join-columns target-column columns-selector)</code><code>(join-columns target-column columns-selector conf)</code></div><div class="doc"><div class="markdown"><p>Join clumns of dataset. Accepts: dataset column selector (as in select-columns) options <code>:separator</code> (default -) <code>:drop-columns?</code> - whether to drop source columns or not (default true) <code>:result-type</code>  <code>:map</code> - packs data into map  <code>:seq</code> - packs data into sequence  <code>:string</code> - join strings with separator (default)  or custom function which gets row as a vector <code>:missing-subst</code> - substitution for missing value</p></div></div></div><div class="public anchor" id="var-labels"><h3>labels</h3><div class="usage"><code>(labels)</code></div><div class="doc"><div class="markdown"><p>Return the labels. The labels sequence is the reverse mapped inference column. This returns a single column of data or errors out.</p></div></div></div><div class="public anchor" id="var-last"><h3>last</h3><div class="usage"><code>(last)</code></div><div class="doc"><div class="markdown"><p>Last row</p></div></div></div><div class="public anchor" id="var-left-join"><h3>left-join</h3><div class="usage"><code>(left-join ds-right columns-selector)</code><code>(left-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-map-columns"><h3>map-columns</h3><div class="usage"><code>(map-columns column-name map-fn)</code><code>(map-columns column-name columns-selector map-fn)</code><code>(map-columns column-name new-type columns-selector map-fn)</code></div><div class="doc"><div class="markdown"><p>Map over rows using a map function. The arity should match the columns selected.</p></div></div></div><div class="public anchor" id="var-map-rows"><h3>map-rows</h3><div class="usage"><code>(map-rows map-fn)</code><code>(map-rows map-fn options)</code></div><div class="doc"><div class="markdown"><p>Map a function across the rows of the dataset producing a new dataset that is merged back into the original potentially replacing existing columns.</p></div></div></div><div class="public anchor" id="var-mapseq-reader"><h3>mapseq-reader</h3><div class="usage"><code>(mapseq-reader options)</code><code>(mapseq-reader)</code></div><div class="doc"><div class="markdown"><p>Return a reader that produces a map of column-name-&gt;column-value upon read.</p></div></div></div><div class="public anchor" id="var-mark-as-group"><h3>mark-as-group</h3><div class="usage"><code>(mark-as-group)</code></div><div class="doc"><div class="markdown"><p>Add grouping tag</p></div></div></div><div class="public anchor" id="var-min-max-scale"><h3>min-max-scale</h3><div class="usage"><code>(min-max-scale columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Metamorph transfomer, which scales the column data into a given range.</p>
<p><code>columns-selector</code> tablecloth columns-selector to choose columns to work on <code>meta-field</code> tablecloth meta-field working with <code>columns-selector</code></p>
<p><code>options</code> Options for scaler, can take:  <code>min</code> Minimal value to scale to (default -0.5)  <code>max</code> Maximum value to scale to (default 0.5)</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Scales the dataset at key <code>:metamorph/data</code> and stores the trained model in ctx under key at <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained min-max-scale model from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use for from key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in key $id</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-min-n-by-column"><h3>min-n-by-column</h3><div class="usage"><code>(min-n-by-column cname N comparator options)</code><code>(min-n-by-column cname N comparator)</code><code>(min-n-by-column cname N)</code></div><div class="doc"><div class="markdown"><p>Find the minimum N entries (unsorted) by column. Resulting data will be indexed in  original order. If you want a sorted order then sort the result.</p>
<p>See options to <a href="scicloj.ml.metamorph.html#var-sort-by-column">sort-by-column</a>.</p>
<p>Example:</p>
<pre><code class="clojure">user&gt; (ds/min-n-by-column ds "price" 10 nil nil)
test/data/stocks.csv [10 3]:

| symbol |       date | price |
|--------|------------|------:|
|   AMZN | 2001-09-01 |  5.97 |
|   AMZN | 2001-10-01 |  6.98 |
|   AAPL | 2000-12-01 |  7.44 |
|   AAPL | 2002-08-01 |  7.38 |
|   AAPL | 2002-09-01 |  7.25 |
|   AAPL | 2002-12-01 |  7.16 |
|   AAPL | 2003-01-01 |  7.18 |
|   AAPL | 2003-02-01 |  7.51 |
|   AAPL | 2003-03-01 |  7.07 |
|   AAPL | 2003-04-01 |  7.11 |
user&gt; (ds/min-n-by-column ds "price" 10 &gt; nil)
test/data/stocks.csv [10 3]:

| symbol |       date |  price |
|--------|------------|-------:|
|   GOOG | 2007-09-01 | 567.27 |
|   GOOG | 2007-10-01 | 707.00 |
|   GOOG | 2007-11-01 | 693.00 |
|   GOOG | 2007-12-01 | 691.48 |
|   GOOG | 2008-01-01 | 564.30 |
|   GOOG | 2008-04-01 | 574.29 |
|   GOOG | 2008-05-01 | 585.80 |
|   GOOG | 2009-11-01 | 583.00 |
|   GOOG | 2009-12-01 | 619.98 |
|   GOOG | 2010-03-01 | 560.19 |
</code></pre></div></div></div><div class="public anchor" id="var-missing"><h3>missing</h3><div class="usage"><code>(missing)</code></div><div class="doc"><div class="markdown"><p>Given a dataset or a column, return the missing set as a roaring bitmap</p></div></div></div><div class="public anchor" id="var-model"><h3>model</h3><div class="usage"><code>(model options)</code></div><div class="doc"><div class="markdown"><p>Executes a machine learning model in train/predict (depending on :mode) from the <code>metamorph.ml</code> model registry.</p>
<p>The model is passed between both invocation via the shared context ctx in a key (a step indentifier) which is passed in key <code>:metamorph/id</code> and guarantied to be unique for each pipeline step.</p>
<p>The function writes and reads into this common context key.</p>
<p>Options: - <code>:model-type</code> - Keyword for the model to use</p>
<p>Further options get passed to <code>train</code> functions and are model specific.</p>
<p>See here for an overview for the models build into scicloj.ml:</p>
<p><a href="https://scicloj.github.io/scicloj.ml-tutorials/userguide-models.html">https://scicloj.github.io/scicloj.ml-tutorials/userguide-models.html</a></p>
<p>Other libraries might contribute other models, which are documented as part of the library.</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Calls <code>scicloj.metamorph.ml/train</code> using data in <code>:metamorph/data</code> and <code>options</code>and stores trained model in ctx under key in <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained model from ctx and calls <code>scicloj.metamorph.ml/predict</code> with the model in $id and data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use for prediction from key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in key $id and writes feature-ds and target-ds before prediction into ctx at <code>:scicloj.metamorph.ml/feature-ds</code> /<code>:scicloj.metamorph.ml/target-ds</code></td>
    </tr>
  </tbody>
</table>
<p>See as well:</p>
<ul>
  <li><code>scicloj.metamorph.ml/train</code></li>
  <li><code>scicloj.metamorph.ml/predict</code></li>
</ul></div></div></div><div class="public anchor" id="var-model-type"><h3>model-type</h3><div class="usage"><code>(model-type &amp; args)</code></div><div class="doc"><div class="markdown"><p>Check the label column after dataset processing. Return either :regression :classification</p></div></div></div><div class="public anchor" id="var-new-column"><h3>new-column</h3><div class="usage"><code>(new-column data)</code><code>(new-column data metadata)</code><code>(new-column data metadata missing)</code><code>(new-column)</code></div><div class="doc"><div class="markdown"><p>Create a new column. Data will scanned for missing values unless the full 4-argument pathway is used.</p></div></div></div><div class="public anchor" id="var-new-dataset"><h3>new-dataset</h3><div class="usage"><code>(new-dataset ds-metadata column-seq)</code><code>(new-dataset column-seq)</code><code>(new-dataset)</code></div><div class="doc"><div class="markdown"><p>Create a new dataset from a sequence of columns. Data will be converted into columns using ds-col-proto/ensure-column-seq. If the column seq is simply a collection of vectors, for instance, columns will be named ordinally. options map -  :dataset-name - Name of the dataset. Defaults to "_unnamed".  :key-fn - Key function used on all column names before insertion into dataset.</p>
<p>The return value fulfills the dataset protocols.</p></div></div></div><div class="public anchor" id="var-num-inference-classes"><h3>num-inference-classes</h3><div class="usage"><code>(num-inference-classes)</code></div><div class="doc"><div class="markdown"><p>Given a dataset and correctly built options from pipeline operations, return the number of classes used for the label. Error if not classification dataset.</p></div></div></div><div class="public anchor" id="var-order-by"><h3>order-by</h3><div class="usage"><code>(order-by columns-or-fn)</code><code>(order-by columns-or-fn comparators)</code><code>(order-by columns-or-fn comparators options)</code></div><div class="doc"><div class="markdown"><p>Order dataset by: - column name - columns (as sequence of names) - key-fn - sequence of columns / key-fn Additionally you can ask the order by: - :asc - :desc - custom comparator function</p></div></div></div><div class="public anchor" id="var-order-column-names"><h3>order-column-names</h3><div class="usage"><code>(order-column-names colname-seq)</code></div><div class="doc"><div class="markdown"><p>Order a sequence of columns names so they match the order in the original dataset. Missing columns are placed last.</p></div></div></div><div class="public anchor" id="var-pivot-.3Elonger"><h3>pivot-&gt;longer</h3><div class="usage"><code>(pivot-&gt;longer)</code><code>(pivot-&gt;longer columns-selector)</code><code>(pivot-&gt;longer columns-selector options)</code></div><div class="doc"><div class="markdown"><p><code>tidyr</code> pivot_longer api</p></div></div></div><div class="public anchor" id="var-pivot-.3Ewider"><h3>pivot-&gt;wider</h3><div class="usage"><code>(pivot-&gt;wider columns-selector value-columns)</code><code>(pivot-&gt;wider columns-selector value-columns options)</code></div><div class="doc"><div class="markdown"><p>Converts columns to rows. Arguments: * dataset * columns selector * options:  <code>:target-columns</code> - names of the columns created or columns pattern (see below) (default: :$column)  <code>:value-column-name</code> - name of the column for values (default: :$value)  <code>:splitter</code> - string, regular expression or function which splits source column names into data  <code>:drop-missing?</code> - remove rows with missing? (default: true)  <code>:datatypes</code> - map of target columns data types  <code>:coerce-to-number</code> - try to convert extracted values to numbers if possible (default: true)</p>
<ul>
  <li>
  <p>target-columns - can be:</p></li>
  <li>
  <p>column name - source columns names are put there as a data</p></li>
  <li>column names as seqence - source columns names after split are put separately into :target-columns as data</li>
  <li>pattern - is a sequence of names, where some of the names are nil. nil is replaced by a name taken from splitter and such column is used for values.</li>
</ul></div></div></div><div class="public anchor" id="var-pmap-ds"><h3>pmap-ds</h3><div class="usage"><code>(pmap-ds ds-map-fn options)</code><code>(pmap-ds ds-map-fn)</code></div><div class="doc"><div class="markdown"><p>Parallelize mapping a function from dataset-&gt;dataset across a single dataset. Results are coalesced back into a single dataset. The original dataset is simple sliced into n-core results and map-fn is called n-core times. ds-map-fn must be a function from dataset-&gt;dataset although it may return nil.</p>
<p>Options:</p>
<ul>
  <li><code>:max-batch-size</code> - this is a default for tech.v3.parallel.for/indexed-map-reduce. You can control how many rows are processed in a given batch - the default is 64000. If your mapping pathway produces a large expansion in the size of the dataset then it may be good to reduce the max batch size and use :as-seq to produce a sequence of datasets.</li>
  <li><code>:result-type</code></li>
  <li><code>:as-seq</code> - Return a sequence of datasets, one for each batch.</li>
  <li><code>:as-ds</code> - Return a single datasets with all results in memory (default option).</li>
</ul></div></div></div><div class="public anchor" id="var-print-all"><h3>print-all</h3><div class="usage"><code>(print-all)</code></div><div class="doc"><div class="markdown"><p>Helper function equivalent to <code>(tech.v3.dataset.print/print-range ... :all)</code></p></div></div></div><div class="public anchor" id="var-print-dataset"><h3>print-dataset</h3><div class="usage"><code>(print-dataset)</code><code>(print-dataset options)</code></div><div class="doc"><div class="markdown"><p>Prints dataset into console. For options see tech.v3.dataset.print/dataset-data-&gt;str</p></div></div></div><div class="public anchor" id="var-probability-distributions-.3Elabel-column"><h3>probability-distributions-&gt;label-column</h3><div class="usage"><code>(probability-distributions-&gt;label-column dst-colname)</code></div><div class="doc"><div class="markdown"><p>Given a dataset that has columns in which the column names describe labels and the rows describe a probability distribution, create a label column by taking the max value in each row and assign column that row value.</p></div></div></div><div class="public anchor" id="var-process-group-data"><h3>process-group-data</h3><div class="usage"><code>(process-group-data f)</code><code>(process-group-data f parallel?)</code></div><div class="doc"><div class="markdown"><p>Internal: The passed-in function is applied on all groups</p></div></div></div><div class="public anchor" id="var-rand-nth"><h3>rand-nth</h3><div class="usage"><code>(rand-nth)</code><code>(rand-nth options)</code></div><div class="doc"><div class="markdown"><p>Returns single random row</p></div></div></div><div class="public anchor" id="var-random"><h3>random</h3><div class="usage"><code>(random)</code><code>(random n)</code><code>(random n options)</code></div><div class="doc"><div class="markdown"><p>Returns (n) random rows with repetition</p></div></div></div><div class="public anchor" id="var-read-nippy"><h3>read-nippy</h3><div class="usage"><code>(read-nippy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-reduce-dimensions"><h3>reduce-dimensions</h3><div class="usage"><code>(reduce-dimensions algorithm target-dims cnames opts)</code></div><div class="doc"><div class="markdown"><p>Metamorph transformer, which reduces the dimensions of a given dataset.</p>
<p><code>algorithm</code> can be any of:  * :pca-cov  * :pca-cor  * :pca-prob  * :kpca  * :gha  * :random</p>
<p><code>target-dims</code> is number of dimensions to reduce to.</p>
<p><code>cnames</code> is a sequence of column names on which the reduction get performed</p>
<p><code>opts</code> are the options of the algorithm</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Reduces dimensions of the dataset at key <code>:metamorph/data</code> and stores the trained model in ctx under key at <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained reduction model from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use from ctx at key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in ctx under key in <code>:metamorph/id</code>.</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-remove-column"><h3>remove-column</h3><div class="usage"><code>(remove-column col-name)</code></div><div class="doc"><div class="markdown"><p>Same as:</p>
<pre><code class="clojure">(dissoc dataset col-name)
</code></pre></div></div></div><div class="public anchor" id="var-remove-columns"><h3>remove-columns</h3><div class="usage"><code>(remove-columns colname-seq-or-fn)</code></div><div class="doc"><div class="markdown"><p>Remove columns indexed by column name seq or column filter function.  For example:</p>
<pre><code class="clojure">  (remove-columns DS [:A :B])
  (remove-columns DS cf/categorical)
</code></pre></div></div></div><div class="public anchor" id="var-remove-rows"><h3>remove-rows</h3><div class="usage"><code>(remove-rows row-indexes)</code></div><div class="doc"><div class="markdown"><p>Same as drop-rows.</p></div></div></div><div class="public anchor" id="var-rename-columns"><h3>rename-columns</h3><div class="usage"><code>(rename-columns columns-selector columns-map-fn)</code><code>(rename-columns columns-mapping)</code></div><div class="doc"><div class="markdown"><p>Rename columns with provided old -&gt; new name map</p></div></div></div><div class="public anchor" id="var-reorder-columns"><h3>reorder-columns</h3><div class="usage"><code>(reorder-columns columns-selector &amp; args)</code></div><div class="doc"><div class="markdown"><p>Reorder columns using column selector(s). When column names are incomplete, the missing will be attached at the end.</p></div></div></div><div class="public anchor" id="var-replace-missing"><h3>replace-missing</h3><div class="usage"><code>(replace-missing)</code><code>(replace-missing strategy)</code><code>(replace-missing columns-selector strategy)</code><code>(replace-missing columns-selector strategy value)</code></div><div class="doc"><div class="markdown"><p>Replaces missing values. Accepts</p>
<ul>
  <li>dataset</li>
  <li>column selector, default: :all</li>
  <li>strategy, default: :nearest</li>
  <li>value (optional)</li>
  <li>single value</li>
  <li>sequence of values (cycled)</li>
  <li>function, applied on column(s) with stripped missings</li>
</ul>
<p>Strategies are:</p>
<p><code>:value</code> - replace with given value <code>:up</code> - copy values up <code>:down</code> - copy values down <code>:updown</code> - copy values up and then down for missing values at the end <code>:downup</code> - copy values down and then up for missing values at the beginning <code>:mid</code> or <code>:nearest</code> - copy values around known values <code>:midpoint</code> - use average value from previous and next non-missing <code>:lerp</code> - trying to lineary approximate values, works for numbers and datetime, otherwise applies :nearest. For numbers always results in float datatype.</p></div></div></div><div class="public anchor" id="var-replace-missing-value"><h3>replace-missing-value</h3><div class="usage"><code>(replace-missing-value filter-fn-or-ds scalar-value)</code><code>(replace-missing-value scalar-value)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-reverse-rows"><h3>reverse-rows</h3><div class="usage"><code>(reverse-rows)</code></div><div class="doc"><div class="markdown"><p>Reverse the rows in the dataset or column.</p></div></div></div><div class="public anchor" id="var-right-join"><h3>right-join</h3><div class="usage"><code>(right-join ds-right columns-selector)</code><code>(right-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-row-at"><h3>row-at</h3><div class="usage"><code>(row-at idx)</code></div><div class="doc"><div class="markdown"><p>Get the row at an individual index. If indexes are negative then the dataset  is indexed from the end.</p>
<pre><code class="clojure">user&gt; (ds/row-at stocks 1)
{"date" #object[java.time.LocalDate 0x534cb03b "2000-02-01"],
 "symbol" "MSFT",
 "price" 36.35}
user&gt; (ds/row-at stocks -1)
{"date" #object[java.time.LocalDate 0x6bf60ed5 "2010-03-01"],
 "symbol" "AAPL",
 "price" 223.02}
</code></pre></div></div></div><div class="public anchor" id="var-row-count"><h3>row-count</h3><div class="usage"><code>(row-count)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-row-map"><h3>row-map</h3><div class="usage"><code>(row-map map-fn options)</code><code>(row-map map-fn)</code></div><div class="doc"><div class="markdown"><p>Map a function across the rows of the dataset producing a new dataset  that is merged back into the original potentially replacing existing columns.  Options are passed into the <a href="null">-&gt;dataset</a> function so you can control the resulting  column types by the usual dataset parsing options described there.</p>
<p>Options:</p>
<p>See options for <a href="scicloj.ml.metamorph.html#var-pmap-ds">pmap-ds</a>. In particular, note that you can  produce a sequence of datasets as opposed to a single large dataset.</p>
<p>Speed demons should attempt both <code>{:copying? false}</code> and <code>{:copying? true}</code> in the options  map as that changes rather drastically how data is read from the datasets. If you are  going to read all the data in the dataset, <code>{:copying? true}</code> will most likely be  the faster of the two.</p>
<p>Examples:</p>
<pre><code class="clojure">user&gt; (def stocks (ds/-&gt;dataset "test/data/stocks.csv"))
#'user/stocks
user&gt; (ds/head stocks)
test/data/stocks.csv [5 3]:

| symbol |       date | price |
|--------|------------|------:|
|   MSFT | 2000-01-01 | 39.81 |
|   MSFT | 2000-02-01 | 36.35 |
|   MSFT | 2000-03-01 | 43.22 |
|   MSFT | 2000-04-01 | 28.37 |
|   MSFT | 2000-05-01 | 25.45 |
user&gt; (ds/head (ds/row-map stocks (fn [row]
                                    {"symbol" (keyword (row "symbol"))
                                     :price2 (* (row "price")(row "price"))})))
test/data/stocks.csv [5 4]:

| symbol |       date | price |   :price2 |
|--------|------------|------:|----------:|
|  :MSFT | 2000-01-01 | 39.81 | 1584.8361 |
|  :MSFT | 2000-02-01 | 36.35 | 1321.3225 |
|  :MSFT | 2000-03-01 | 43.22 | 1867.9684 |
|  :MSFT | 2000-04-01 | 28.37 |  804.8569 |
|  :MSFT | 2000-05-01 | 25.45 |  647.7025 |
</code></pre></div></div></div><div class="public anchor" id="var-row-mapcat"><h3>row-mapcat</h3><div class="usage"><code>(row-mapcat mapcat-fn options)</code><code>(row-mapcat mapcat-fn)</code></div><div class="doc"><div class="markdown"><p>Map a function across the rows of the dataset. The function must produce a sequence of  maps and the original dataset rows will be duplicated and then merged into the result  of calling (-&gt;&gt; (apply concat) (-&gt;&gt;dataset options) on the result of <code>mapcat-fn</code>. Options  are the same as <a href="null">-&gt;dataset</a>.</p>
<p>The smaller the maps returned from mapcat-fn the better, perhaps consider using records.  In the case that a mapcat-fn result map has a key that overlaps a column name the  column will be replaced with the output of mapcat-fn. The returned map will have the  key <code>:_row-id</code> assoc’d onto it so for absolutely minimal gc usage include this  as a member variable in your map.</p>
<p>Options:</p>
<ul>
  <li>See options for <a href="scicloj.ml.metamorph.html#var-pmap-ds">pmap-ds</a>. Especially note <code>:max-batch-size</code> and <code>:result-type</code>.  In order to conserve memory it may be much more efficient to return a sequence of datasets  rather than one large dataset. If returning sequences of datasets perhaps consider  a transducing pathway across them or the <a href="null">tech.v3.dataset.reductions</a> namespace.</li>
</ul>
<p>Example:</p>
<pre><code class="clojure">user&gt; (def ds (ds/-&gt;dataset {:rid (range 10)
                             :data (repeatedly 10 #(rand-int 3))}))
#'user/ds
user&gt; (ds/head ds)
_unnamed [5 2]:

| :rid | :data |
|-----:|------:|
|    0 |     0 |
|    1 |     2 |
|    2 |     0 |
|    3 |     1 |
|    4 |     2 |
user&gt; (def mapcat-fn (fn [row]
                       (for [idx (range (row :data))]
                         {:idx idx})))
#'user/mapcat-fn
user&gt; (mapcat mapcat-fn (ds/rows ds))
({:idx 0} {:idx 1} {:idx 0} {:idx 0} {:idx 1} {:idx 0} {:idx 1} {:idx 0} {:idx 1})
user&gt; (ds/row-mapcat ds mapcat-fn)
_unnamed [9 3]:

| :rid | :data | :idx |
|-----:|------:|-----:|
|    1 |     2 |    0 |
|    1 |     2 |    1 |
|    3 |     1 |    0 |
|    4 |     2 |    0 |
|    4 |     2 |    1 |
|    6 |     2 |    0 |
|    6 |     2 |    1 |
|    8 |     2 |    0 |
|    8 |     2 |    1 |
user&gt;
</code></pre></div></div></div><div class="public anchor" id="var-rows"><h3>rows</h3><div class="usage"><code>(rows)</code><code>(rows result-type)</code><code>(rows result-type options)</code></div><div class="doc"><div class="markdown"><p>Returns rows of dataset. Result type can be any of: * <code>:as-maps</code> - maps * <code>:as-double-arrays</code> - double arrays * <code>:as-seqs</code> - reader (sequence, default) * <code>:as-vecs</code> - vectors</p>
<p>If you want to elide nils in maps set <code>:nil-missing?</code> option to false (default: <code>true</code>). Another option - <code>:copying?</code> - when true row values are copied on read (default: <code>false</code>).</p></div></div></div><div class="public anchor" id="var-rowvec-at"><h3>rowvec-at</h3><div class="usage"><code>(rowvec-at idx)</code></div><div class="doc"><div class="markdown"><p>Return a persisent-vector-like row at a given index. Negative indexes index  from the end.</p>
<pre><code class="clojure">user&gt; (ds/rowvec-at stocks 1)
["MSFT" #object[java.time.LocalDate 0x5848b8b3 "2000-02-01"] 36.35]
user&gt; (ds/rowvec-at stocks -1)
["AAPL" #object[java.time.LocalDate 0x4b70b0d5 "2010-03-01"] 223.02]
</code></pre></div></div></div><div class="public anchor" id="var-rowvecs"><h3>rowvecs</h3><div class="usage"><code>(rowvecs options)</code><code>(rowvecs)</code></div><div class="doc"><div class="markdown"><p>Return a randomly addressable list of rows in persistent vector-like form.</p>
<p>Options:</p>
<ul>
  <li>copying? - When true the data is copied out of the dataset row by row upon read of that  row. When false the data is only referenced upon each read of a particular key. Copying  is appropriate if you want to use the row values as keys a map and it is inappropriate if  you are only going to read a given key for a given row once.</li>
</ul>
<pre><code class="clojure">user&gt; (take 5 (ds/rowvecs stocks))
(["MSFT" #object[java.time.LocalDate 0x5be9e4c8 "2000-01-01"] 39.81]
 ["MSFT" #object[java.time.LocalDate 0xf758e5 "2000-02-01"] 36.35]
 ["MSFT" #object[java.time.LocalDate 0x752cc84d "2000-03-01"] 43.22]
 ["MSFT" #object[java.time.LocalDate 0x7bad4827 "2000-04-01"] 28.37]
 ["MSFT" #object[java.time.LocalDate 0x3a62c34a "2000-05-01"] 25.45])
</code></pre></div></div></div><div class="public anchor" id="var-sample"><h3>sample</h3><div class="usage"><code>(sample n options)</code><code>(sample n)</code><code>(sample)</code></div><div class="doc"><div class="markdown"><p>Sample n-rows from a dataset. Defaults to sampling <em>without</em> replacement.</p>
<p>For the definition of seed, see the argshuffle documentation](<a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argshuffle">https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argshuffle</a>)</p>
<p>The returned dataset’s metadata is altered merging <code>{:print-index-range (range n)}</code> in so you will always see the entire returned dataset. If this isn’t desired, <code>vary-meta</code> a good pathway.</p>
<p>Options:</p>
<ul>
  <li><code>:replacement?</code> - Do sampling with replacement. Defaults to false.</li>
  <li><code>:seed</code> - Provide a seed as a number or provide a Random implementation.</li>
</ul></div></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Select columns and rows.</p></div></div></div><div class="public anchor" id="var-select-by-index"><h3>select-by-index</h3><div class="usage"><code>(select-by-index col-index row-index)</code></div><div class="doc"><div class="markdown"><p>Trim dataset according to this sequence of indexes. Returns a new dataset.</p>
<p>col-index and row-index - one of:</p>
<ul>
  <li>:all - all the columns</li>
  <li>list of indexes. May contain duplicates. Negative values will be counted from the end of the sequence.</li>
</ul></div></div></div><div class="public anchor" id="var-select-columns"><h3>select-columns</h3><div class="usage"><code>(select-columns)</code><code>(select-columns columns-selector)</code><code>(select-columns columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Select columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-select-columns-by-index"><h3>select-columns-by-index</h3><div class="usage"><code>(select-columns-by-index col-index)</code></div><div class="doc"><div class="markdown"><p>Select columns from the dataset by seq of index(includes negative) or :all.</p>
<p>See documentation for <code>select-by-index</code>.</p></div></div></div><div class="public anchor" id="var-select-missing"><h3>select-missing</h3><div class="usage"><code>(select-missing)</code><code>(select-missing columns-selector)</code></div><div class="doc"><div class="markdown"><p>Select rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-select-rows"><h3>select-rows</h3><div class="usage"><code>(select-rows)</code><code>(select-rows rows-selector)</code><code>(select-rows rows-selector options)</code></div><div class="doc"><div class="markdown"><p>Select rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-semi-join"><h3>semi-join</h3><div class="usage"><code>(semi-join ds-right columns-selector)</code><code>(semi-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-separate-column"><h3>separate-column</h3><div class="usage"><code>(separate-column column)</code><code>(separate-column column separator)</code><code>(separate-column column target-columns separator)</code><code>(separate-column column target-columns separator conf)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-dataset-name"><h3>set-dataset-name</h3><div class="usage"><code>(set-dataset-name ds-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-inference-target"><h3>set-inference-target</h3><div class="usage"><code>(set-inference-target target-name-or-target-name-seq)</code></div><div class="doc"><div class="markdown"><p>Set the inference target on the column. This sets the :column-type member of the column metadata to :inference-target?.</p></div></div></div><div class="public anchor" id="var-shape"><h3>shape</h3><div class="usage"><code>(shape)</code></div><div class="doc"><div class="markdown"><p>Returns shape of the dataset [rows, cols]</p></div></div></div><div class="public anchor" id="var-shuffle"><h3>shuffle</h3><div class="usage"><code>(shuffle)</code><code>(shuffle options)</code></div><div class="doc"><div class="markdown"><p>Shuffle dataset (with seed)</p></div></div></div><div class="public anchor" id="var-sort-by"><h3>sort-by</h3><div class="usage"><code>(sort-by key-fn compare-fn &amp; args)</code><code>(sort-by key-fn)</code></div><div class="doc"><div class="markdown"><p>Sort a dataset by a key-fn and compare-fn.</p>
<ul>
  <li><code>key-fn</code> - function from map to sort value.</li>
  <li><code>compare-fn</code> may be one of:</li>
  <li>a clojure operator like clojure.core/&lt;</li>
  <li><code>:tech.numerics/&lt;</code>, <code>:tech.numerics/&gt;</code> for unboxing comparisons of primitive  values.</li>
  <li>clojure.core/compare</li>
  <li>A custom java.util.Comparator instantiation.</li>
</ul>
<p>Options:</p>
<ul>
  <li><code>:nan-strategy</code> - General missing strategy. Options are <code>:first</code>, <code>:last</code>, and  <code>:exception</code>.</li>
  <li><code>:parallel?</code> - Uses parallel quicksort when true and regular quicksort when false.</li>
</ul></div></div></div><div class="public anchor" id="var-sort-by-column"><h3>sort-by-column</h3><div class="usage"><code>(sort-by-column colname compare-fn &amp; args)</code><code>(sort-by-column colname)</code></div><div class="doc"><div class="markdown"><p>Sort a dataset by a given column using the given compare fn.</p>
<ul>
  <li><code>compare-fn</code> may be one of:</li>
  <li>a clojure operator like clojure.core/&lt;</li>
  <li><code>:tech.numerics/&lt;</code>, <code>:tech.numerics/&gt;</code> for unboxing comparisons of primitive  values.</li>
  <li>clojure.core/compare</li>
  <li>A custom java.util.Comparator instantiation.</li>
</ul>
<p>Options:</p>
<ul>
  <li><code>:nan-strategy</code> - General missing strategy. Options are <code>:first</code>, <code>:last</code>, and  <code>:exception</code>.</li>
  <li><code>:parallel?</code> - Uses parallel quicksort when true and regular quicksort when false.</li>
</ul></div></div></div><div class="public anchor" id="var-std-scale"><h3>std-scale</h3><div class="usage"><code>(std-scale columns-selector meta-field options)</code><code>(std-scale columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Metamorph transfomer, which centers and scales the dataset per column.</p>
<p><code>columns-selector</code> tablecloth columns-selector to choose columns to work on <code>meta-field</code> tablecloth meta-field working with <code>columns-selector</code></p>
<p><code>options</code> are the options for the scaler and can take:  <code>mean?</code> If true (default), the data gets shifted by the column means, so 0 centered  <code>stddev?</code> If true (default), the data gets scaled by the standard deviation of the column</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Centers and scales the dataset at key <code>:metamorph/data</code> and stores the trained model in ctx under key at <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained std-scale model from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use for from key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in key $id</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-tail"><h3>tail</h3><div class="usage"><code>(tail)</code><code>(tail n)</code></div><div class="doc"><div class="markdown"><p>Last n rows (default 5)</p></div></div></div><div class="public anchor" id="var-take-nth"><h3>take-nth</h3><div class="usage"><code>(take-nth n-val)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-transform-one-hot"><h3>transform-one-hot</h3><div class="usage"><code>(transform-one-hot column-selector strategy)</code><code>(transform-one-hot column-selector strategy options)</code></div><div class="doc"><div class="markdown"><p>Transformer which mapps categorical variables to numbers. Each value of the column gets its won column in one-hot-encoding.</p>
<p>To handle different levls of a variable between train an test data, three strategies are available:</p>
<ul>
  <li><code>:full</code> The levels are retrieved from a dataset at key :metamorph.ml/full-ds in the context</li>
  <li><code>:independent</code> One-hot columns are fitted and transformed independently for train and test data</li>
  <li><code>:fit</code> The mapping fitted in mode :fit is used in :transform, and it is assumed that all levels are present in the data during :fit</li>
</ul>
<p><code>options</code> can be: * <code>:table-args</code> allows to specify the precise mapping as a sequence of pairs of [val idx] or as a sorted seq of values. * <code>:result-datatype</code> Datatype of the one-hot-mapping column</p></div></div></div><div class="public anchor" id="var-ungroup"><h3>ungroup</h3><div class="usage"><code>(ungroup)</code><code>(ungroup options)</code></div><div class="doc"><div class="markdown"><p>Concat groups into dataset.</p>
<p>When <code>add-group-as-column</code> or <code>add-group-id-as-column</code> is set to <code>true</code> or name(s), columns with group name(s) or group id is added to the result.</p>
<p>Before joining the groups groups can be sorted by group name.</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-unique-by"><h3>unique-by</h3><div class="usage"><code>(unique-by)</code><code>(unique-by columns-selector)</code><code>(unique-by columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Remove rows which contains the same data <code>column-selector</code> Select columns for uniqueness <code>strategy</code> There are 4 strategies defined to handle duplicates</p>
<p><code>:first</code> - select first row (default)  <code>:last</code> - select last row  <code>:random</code> - select random row  any function - apply function to a columns which are subject of uniqueness</p></div></div></div><div class="public anchor" id="var-unique-by-column"><h3>unique-by-column</h3><div class="usage"><code>(unique-by-column options colname)</code><code>(unique-by-column colname)</code></div><div class="doc"><div class="markdown"><p>Map-fn function gets passed map for each row, rows are grouped by the return value. Keep-fn is used to decide the index to keep.</p>
<p>:keep-fn - Function from key, idx-seq-&gt;idx. Defaults to #(first %2).</p></div></div></div><div class="public anchor" id="var-unmark-group"><h3>unmark-group</h3><div class="usage"><code>(unmark-group)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-unordered-select"><h3>unordered-select</h3><div class="usage"><code>(unordered-select colname-seq index-seq)</code></div><div class="doc"><div class="markdown"><p>Perform a selection but use the order of the columns in the existing table; do <em>not</em> reorder the columns based on colname-seq. Useful when doing selection based on sets or persistent hash maps.</p></div></div></div><div class="public anchor" id="var-unroll"><h3>unroll</h3><div class="usage"><code>(unroll columns-selector)</code><code>(unroll columns-selector options)</code></div><div class="doc"><div class="markdown"><p>Unfolds sequences stored inside a column(s), turning it into multiple columns. Opposite of <a href="scicloj.ml.metamorph.html#var-fold-by">fold-by</a>. Add each of the provided columns to the set that defines the “uniqe key” of each row. Thus there will be a new row for each value inside the target column(s)’ value sequence. If you want instead to split the content of the columns into a set of new <em>columns</em>, look at <a href="scicloj.ml.metamorph.html#var-separate-column">separate-column</a>. See <a href="https://scicloj.github.io/tablecloth/index.html#Unroll">https://scicloj.github.io/tablecloth/index.html#Unroll</a></p></div></div></div><div class="public anchor" id="var-unroll-column"><h3>unroll-column</h3><div class="usage"><code>(unroll-column column-name)</code><code>(unroll-column column-name options)</code></div><div class="doc"><div class="markdown"><p>Unroll a column that has some (or all) sequential data as entries.  Returns a new dataset with same columns but with other columns duplicated  where the unroll happened. Column now contains only scalar data.</p>
<p>Any missing indexes are dropped.</p>
<pre><code class="clojure">user&gt; (-&gt; (ds/-&gt;dataset [{:a 1 :b [2 3]}
                              {:a 2 :b [4 5]}
                              {:a 3 :b :a}])
               (ds/unroll-column :b {:indexes? true}))
  _unnamed [5 3]:

| :a | :b | :indexes |
|----+----+----------|
|  1 |  2 |        0 |
|  1 |  3 |        1 |
|  2 |  4 |        0 |
|  2 |  5 |        1 |
|  3 | :a |        0 |
</code></pre>
<p>Options -  :datatype - datatype of the resulting column if one aside from :object is desired.  :indexes? - If true, create a new column that records the indexes of the values from  the original column. Can also be a truthy value (like a keyword) and the column  will be named this.</p></div></div></div><div class="public anchor" id="var-update"><h3>update</h3><div class="usage"><code>(update filter-fn-or-ds update-fn &amp; args)</code></div><div class="doc"><div class="markdown"><p>Update this dataset. Filters this dataset into a new dataset,  applies update-fn, then merges the result into original dataset.</p>
<p>This pathways is designed to work with the tech.v3.dataset.column-filters namespace.</p>
<ul>
  <li><code>filter-fn-or-ds</code> is a generalized parameter. May be a function,  a dataset or a sequence of column names.</li>
  <li>update-fn must take the dataset as the first argument and must return  a dataset.</li>
</ul>
<pre><code class="clojure">(ds/bind-&gt; (ds/-&gt;dataset dataset) ds
           (ds/remove-column "Id")
           (ds/update cf/string ds/replace-missing-value "NA")
           (ds/update-elemwise cf/string #(get {"" "NA"} % %))
           (ds/update cf/numeric ds/replace-missing-value 0)
           (ds/update cf/boolean ds/replace-missing-value false)
           (ds/update-columnwise (cf/union (cf/numeric ds) (cf/boolean ds))
                                 #(dtype/elemwise-cast % :float64)))
</code></pre></div></div></div><div class="public anchor" id="var-update-column"><h3>update-column</h3><div class="usage"><code>(update-column col-name update-fn)</code></div><div class="doc"><div class="markdown"><p>Update a column returning a new dataset. update-fn is a column-&gt;column transformation. Error if column does not exist.</p></div></div></div><div class="public anchor" id="var-update-columns"><h3>update-columns</h3><div class="usage"><code>(update-columns columns-map)</code><code>(update-columns columns-selector update-functions)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-update-columnwise"><h3>update-columnwise</h3><div class="usage"><code>(update-columnwise filter-fn-or-ds cwise-update-fn &amp; args)</code></div><div class="doc"><div class="markdown"><p>Call update-fn on each column of the dataset. Returns the dataset. See arguments to update</p></div></div></div><div class="public anchor" id="var-update-elemwise"><h3>update-elemwise</h3><div class="usage"><code>(update-elemwise filter-fn-or-ds map-fn)</code><code>(update-elemwise map-fn)</code></div><div class="doc"><div class="markdown"><p>Replace all elements in selected columns by calling selected function on each element. column-name-seq must be a sequence of column names if provided. filter-fn-or-ds has same rules as update. Implicitly clears the missing set so function must deal with type-specific missing values correctly. Returns new dataset</p></div></div></div><div class="public anchor" id="var-value-reader"><h3>value-reader</h3><div class="usage"><code>(value-reader options)</code><code>(value-reader)</code></div><div class="doc"><div class="markdown"><p>Return a reader that produces a reader of column values per index. Options: :copying? - Default to false - When true row values are copied on read.</p></div></div></div><div class="public anchor" id="var-write.21"><h3>write!</h3><div class="usage"><code>(write! output-path options)</code><code>(write! output-path)</code></div><div class="doc"><div class="markdown"><p>Write a dataset out to a file. Supported forms are:</p>
<pre><code class="clojure">(ds/write! test-ds "test.csv")
(ds/write! test-ds "test.tsv")
(ds/write! test-ds "test.tsv.gz")
(ds/write! test-ds "test.nippy")
(ds/write! test-ds out-stream)
</code></pre>
<p>Options:</p>
<ul>
  <li><code>:max-chars-per-column</code> - csv,tsv specific, defaults to 65536 - values longer than this will  cause an exception during serialization.</li>
  <li><code>:max-num-columns</code> - csv,tsv specific, defaults to 8192 - If the dataset has more than this number of  columns an exception will be thrown during serialization.</li>
  <li><code>:quoted-columns</code> - csv specific - sequence of columns names that you would like to always have quoted.</li>
  <li><code>:file-type</code> - Manually specify the file type. This is usually inferred from the filename but if you  pass in an output stream then you will need to specify the file type.</li>
  <li><code>:headers?</code> - if csv headers are written, defaults to true.</li>
</ul></div></div></div><div class="public anchor" id="var-write-nippy.21"><h3>write-nippy!</h3><div class="usage"><code>(write-nippy! filename)</code></div><div class="doc"><div class="markdown"></div></div></div></div></body></html>